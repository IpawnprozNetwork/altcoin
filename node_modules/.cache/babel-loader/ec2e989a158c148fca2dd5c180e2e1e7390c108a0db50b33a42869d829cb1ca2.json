{"ast":null,"code":"import { detect as ot } from \"detect-browser\";\nimport { toMiliseconds as ee, FIVE_MINUTES as Ie, fromMiliseconds as st } from \"@walletconnect/time\";\nimport { getDocument as ne, getNavigator as Pe, getLocation as je } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as it } from \"@walletconnect/window-metadata\";\nimport * as q from \"query-string\";\nimport { hashMessage as Te } from \"@ethersproject/hash\";\nimport { recoverAddress as ct } from \"@ethersproject/transactions\";\nimport { ChaCha20Poly1305 as Ae } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as at } from \"@stablelib/hkdf\";\nimport { randomBytes as B } from \"@stablelib/random\";\nimport { SHA256 as Ce, hash as Ue } from \"@stablelib/sha256\";\nimport * as _e from \"@stablelib/x25519\";\nimport { toString as v, fromString as w, concat as te } from \"uint8arrays\";\nimport { ec as ut } from \"elliptic\";\nimport { decodeJWT as lt } from \"@walletconnect/relay-auth\";\nimport { RELAY_JSONRPC as dt } from \"@walletconnect/relay-api\";\nconst H = \":\";\nfunction re(e) {\n  const [n, t] = e.split(H);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction ke(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(H);\n}\nfunction oe(e) {\n  const [n, t, r] = e.split(H);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction De(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(H);\n}\nfunction se(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction xe(e) {\n  const {\n    address: n\n  } = oe(e);\n  return n;\n}\nfunction Ve(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = oe(e);\n  return ke({\n    namespace: n,\n    reference: t\n  });\n}\nfunction ft(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = re(n);\n  return De({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction pt(e) {\n  return se(e, xe);\n}\nfunction Me(e) {\n  return se(e, Ve);\n}\nfunction mt(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\nfunction ht(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...Me(o.accounts));\n  }), t;\n}\nfunction yt(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...W(r, o));\n  }), t;\n}\nfunction W(e, n) {\n  return e.includes(\":\") ? [e] : n.chains || [];\n}\nvar gt = Object.defineProperty,\n  Ke = Object.getOwnPropertySymbols,\n  vt = Object.prototype.hasOwnProperty,\n  bt = Object.prototype.propertyIsEnumerable,\n  Le = (e, n, t) => n in e ? gt(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Fe = (e, n) => {\n    for (var t in n || (n = {})) vt.call(n, t) && Le(e, t, n[t]);\n    if (Ke) for (var t of Ke(n)) bt.call(n, t) && Le(e, t, n[t]);\n    return e;\n  };\nconst qe = \"ReactNative\",\n  y = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  J = \" \",\n  Et = \":\",\n  Be = \"/\",\n  ie = 2,\n  wt = 1e3,\n  He = \"js\";\nfunction ce() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction $() {\n  return !ne() && !!Pe() && navigator.product === qe;\n}\nfunction Ot() {\n  return $() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\" && (global == null ? void 0 : global.Platform.OS) === \"android\";\n}\nfunction Nt() {\n  return $() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\" && (global == null ? void 0 : global.Platform.OS) === \"ios\";\n}\nfunction V() {\n  return !ce() && !!Pe() && !!ne();\n}\nfunction A() {\n  return $() ? y.reactNative : ce() ? y.node : V() ? y.browser : y.unknown;\n}\nfunction St() {\n  var e;\n  try {\n    return $() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Application) < \"u\" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;\n  } catch {\n    return;\n  }\n}\nfunction We(e, n) {\n  let t = q.parse(e);\n  return t = Fe(Fe({}, t), n), e = q.stringify(t), e;\n}\nfunction $t() {\n  return it() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction Rt(e, n) {\n  var t;\n  const r = A(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = je()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction Je() {\n  if (A() === y.reactNative && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\") {\n    const {\n      OS: t,\n      Version: r\n    } = global.Platform;\n    return [t, r].join(\"-\");\n  }\n  const e = ot();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction ze() {\n  var e;\n  const n = A();\n  return n === y.browser ? [n, ((e = je()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction Ge(e, n, t) {\n  const r = Je(),\n    o = ze();\n  return [[e, n].join(\"-\"), [He, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction It({\n  protocol: e,\n  version: n,\n  relayUrl: t,\n  sdkVersion: r,\n  auth: o,\n  projectId: s,\n  useOnCloseEvent: i,\n  bundleId: u,\n  packageName: l\n}) {\n  const c = t.split(\"?\"),\n    d = Ge(e, n, r),\n    a = {\n      auth: o,\n      ua: d,\n      projectId: s,\n      useOnCloseEvent: i || void 0,\n      packageName: l || void 0,\n      bundleId: u || void 0\n    },\n    f = We(c[1] || \"\", a);\n  return c[0] + \"?\" + f;\n}\nfunction Pt(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction jt(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\nfunction Ye(e, n = ie) {\n  return Qe(e.split(Be), n);\n}\nfunction Tt(e) {\n  return Ye(e).join(J);\n}\nfunction R(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\nfunction Qe(e, n = ie) {\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction At(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction Ct(e) {\n  return new Map(Object.entries(e));\n}\nfunction Ut(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\nconst _t = e => e;\nfunction Ze(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\nfunction kt(e) {\n  return e.split(J).map(n => Ze(n)).join(J);\n}\nfunction Dt(e = Ie, n) {\n  const t = ee(e || Ie);\n  let r, o, s, i;\n  return {\n    resolve: u => {\n      s && r && (clearTimeout(s), r(u), i = Promise.resolve(u));\n    },\n    reject: u => {\n      s && o && (clearTimeout(s), o(u));\n    },\n    done: () => new Promise((u, l) => {\n      if (i) return u(i);\n      s = setTimeout(() => {\n        const c = new Error(n);\n        i = Promise.reject(c), l(c);\n      }, t), r = u, o = l;\n    })\n  };\n}\nfunction xt(e, n, t) {\n  return new Promise(async (r, o) => {\n    const s = setTimeout(() => o(new Error(t)), n);\n    try {\n      const i = await e;\n      r(i);\n    } catch (i) {\n      o(i);\n    }\n    clearTimeout(s);\n  });\n}\nfunction ae(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\nfunction Vt(e) {\n  return ae(\"topic\", e);\n}\nfunction Mt(e) {\n  return ae(\"id\", e);\n}\nfunction Kt(e) {\n  const [n, t] = e.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\nfunction Lt(e, n) {\n  return st((n || Date.now()) + ee(e));\n}\nfunction Ft(e) {\n  return Date.now() >= ee(e);\n}\nfunction qt(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\nfunction N(e = [], n = []) {\n  return [...new Set([...e, ...n])];\n}\nasync function Bt({\n  id: e,\n  topic: n,\n  wcDeepLink: t\n}) {\n  var r;\n  try {\n    if (!t) return;\n    const o = typeof t == \"string\" ? JSON.parse(t) : t,\n      s = o?.href;\n    if (typeof s != \"string\") return;\n    const i = Xe(s, e, n),\n      u = A();\n    if (u === y.browser) {\n      if (!((r = ne()) != null && r.hasFocus())) {\n        console.warn(\"Document does not have focus, skipping deeplink.\");\n        return;\n      }\n      i.startsWith(\"https://\") || i.startsWith(\"http://\") ? window.open(i, \"_blank\", \"noreferrer noopener\") : window.open(i, en() ? \"_blank\" : \"_self\", \"noreferrer noopener\");\n    } else u === y.reactNative && typeof (global == null ? void 0 : global.Linking) < \"u\" && (await global.Linking.openURL(i));\n  } catch (o) {\n    console.error(o);\n  }\n}\nfunction Xe(e, n, t) {\n  const r = `requestId=${n}&sessionTopic=${t}`;\n  e.endsWith(\"/\") && (e = e.slice(0, -1));\n  let o = `${e}`;\n  if (e.startsWith(\"https://t.me\")) {\n    const s = e.includes(\"?\") ? \"&startapp=\" : \"?startapp=\";\n    o = `${o}${s}${nn(r, !0)}`;\n  } else o = `${o}/wc?${r}`;\n  return o;\n}\nasync function Ht(e, n) {\n  let t = \"\";\n  try {\n    if (V() && (t = localStorage.getItem(n), t)) return t;\n    t = await e.getItem(n);\n  } catch (r) {\n    console.error(r);\n  }\n  return t;\n}\nfunction ue(e, n) {\n  return e.filter(t => n.includes(t));\n}\nfunction Wt(e, n) {\n  if (!e.includes(n)) return null;\n  const t = e.split(/([&,?,=])/),\n    r = t.indexOf(n);\n  return t[r + 2];\n}\nfunction Jt() {\n  return typeof crypto < \"u\" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/gu, e => {\n    const n = Math.random() * 16 | 0;\n    return (e === \"x\" ? n : n & 3 | 8).toString(16);\n  });\n}\nfunction zt() {\n  return typeof process < \"u\" && process.env.IS_VITEST === \"true\";\n}\nfunction en() {\n  return typeof window < \"u\" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);\n}\nfunction nn(e, n = !1) {\n  const t = Buffer.from(e).toString(\"base64\");\n  return n ? t.replace(/[=]/g, \"\") : t;\n}\nfunction le(e) {\n  return Buffer.from(e, \"base64\").toString(\"utf-8\");\n}\nfunction Gt(e) {\n  return new Promise(n => setTimeout(n, e));\n}\nconst Yt = \"https://rpc.walletconnect.org/v1\";\nasync function tn(e, n, t, r, o, s) {\n  switch (t.t) {\n    case \"eip191\":\n      return rn(e, n, t.s);\n    case \"eip1271\":\n      return await on(e, n, t.s, r, o, s);\n    default:\n      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`);\n  }\n}\nfunction rn(e, n, t) {\n  return ct(Te(n), t).toLowerCase() === e.toLowerCase();\n}\nasync function on(e, n, t, r, o, s) {\n  const i = re(r);\n  if (!i.namespace || !i.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`);\n  try {\n    const u = \"0x1626ba7e\",\n      l = \"0000000000000000000000000000000000000000000000000000000000000040\",\n      c = \"0000000000000000000000000000000000000000000000000000000000000041\",\n      d = t.substring(2),\n      a = Te(n).substring(2),\n      f = u + a + l + c + d,\n      h = await fetch(`${s || Yt}/?chainId=${r}&projectId=${o}`, {\n        method: \"POST\",\n        body: JSON.stringify({\n          id: Qt(),\n          jsonrpc: \"2.0\",\n          method: \"eth_call\",\n          params: [{\n            to: e,\n            data: f\n          }, \"latest\"]\n        })\n      }),\n      {\n        result: p\n      } = await h.json();\n    return p ? p.slice(0, u.length).toLowerCase() === u.toLowerCase() : !1;\n  } catch (u) {\n    return console.error(\"isValidEip1271Signature: \", u), !1;\n  }\n}\nfunction Qt() {\n  return Date.now() + Math.floor(Math.random() * 1e3);\n}\nvar Zt = Object.defineProperty,\n  Xt = Object.defineProperties,\n  er = Object.getOwnPropertyDescriptors,\n  sn = Object.getOwnPropertySymbols,\n  nr = Object.prototype.hasOwnProperty,\n  tr = Object.prototype.propertyIsEnumerable,\n  cn = (e, n, t) => n in e ? Zt(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  de = (e, n) => {\n    for (var t in n || (n = {})) nr.call(n, t) && cn(e, t, n[t]);\n    if (sn) for (var t of sn(n)) tr.call(n, t) && cn(e, t, n[t]);\n    return e;\n  },\n  an = (e, n) => Xt(e, er(n));\nconst rr = \"did:pkh:\",\n  z = e => e?.split(\":\"),\n  un = e => {\n    const n = e && z(e);\n    if (n) return e.includes(rr) ? n[3] : n[1];\n  },\n  ln = e => {\n    const n = e && z(e);\n    if (n) return n[2] + \":\" + n[3];\n  },\n  fe = e => {\n    const n = e && z(e);\n    if (n) return n.pop();\n  };\nasync function or(e) {\n  const {\n      cacao: n,\n      projectId: t\n    } = e,\n    {\n      s: r,\n      p: o\n    } = n,\n    s = dn(o, o.iss),\n    i = fe(o.iss);\n  return await tn(i, s, r, ln(o.iss), t);\n}\nconst dn = (e, n) => {\n  const t = `${e.domain} wants you to sign in with your Ethereum account:`,\n    r = fe(n);\n  if (!e.aud && !e.uri) throw new Error(\"Either `aud` or `uri` is required to construct the message\");\n  let o = e.statement || void 0;\n  const s = `URI: ${e.aud || e.uri}`,\n    i = `Version: ${e.version}`,\n    u = `Chain ID: ${un(n)}`,\n    l = `Nonce: ${e.nonce}`,\n    c = `Issued At: ${e.iat}`,\n    d = e.exp ? `Expiration Time: ${e.exp}` : void 0,\n    a = e.nbf ? `Not Before: ${e.nbf}` : void 0,\n    f = e.requestId ? `Request ID: ${e.requestId}` : void 0,\n    h = e.resources ? `Resources:${e.resources.map(m => `\n- ${m}`).join(\"\")}` : void 0,\n    p = Y(e.resources);\n  if (p) {\n    const m = I(p);\n    o = he(o, m);\n  }\n  return [t, r, \"\", o, \"\", s, i, u, l, c, d, a, f, h].filter(m => m != null).join(`\n`);\n};\nfunction sr(e, n, t) {\n  return t.includes(\"did:pkh:\") || (t = `did:pkh:${t}`), {\n    h: {\n      t: \"caip122\"\n    },\n    p: {\n      iss: t,\n      domain: e.domain,\n      aud: e.aud,\n      version: e.version,\n      nonce: e.nonce,\n      iat: e.iat,\n      statement: e.statement,\n      requestId: e.requestId,\n      resources: e.resources,\n      nbf: e.nbf,\n      exp: e.exp\n    },\n    s: n\n  };\n}\nfunction ir(e) {\n  var n;\n  const {\n      authPayload: t,\n      chains: r,\n      methods: o\n    } = e,\n    s = t.statement || \"\";\n  if (!(r != null && r.length)) return t;\n  const i = t.chains,\n    u = ue(i, r);\n  if (!(u != null && u.length)) throw new Error(\"No supported chains\");\n  const l = fn(t.resources);\n  if (!l) return t;\n  O(l);\n  const c = pn(l, \"eip155\");\n  let d = t?.resources || [];\n  if (c != null && c.length) {\n    const a = mn(c),\n      f = ue(a, o);\n    if (!(f != null && f.length)) throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(a)}, supported: ${JSON.stringify(o)}`);\n    const h = pe(\"request\", f, {\n        chains: u\n      }),\n      p = vn(l, \"eip155\", h);\n    d = ((n = t?.resources) == null ? void 0 : n.slice(0, -1)) || [], d.push(G(p));\n  }\n  return an(de({}, t), {\n    statement: En(s, Y(d)),\n    chains: u,\n    resources: t != null && t.resources || d.length > 0 ? d : void 0\n  });\n}\nfunction fn(e) {\n  const n = Y(e);\n  if (n && me(n)) return I(n);\n}\nfunction cr(e, n) {\n  var t;\n  return (t = e?.att) == null ? void 0 : t.hasOwnProperty(n);\n}\nfunction pn(e, n) {\n  var t, r;\n  return (t = e?.att) != null && t[n] ? Object.keys((r = e?.att) == null ? void 0 : r[n]) : [];\n}\nfunction ar(e) {\n  return e?.map(n => Object.keys(n)) || [];\n}\nfunction mn(e) {\n  return e?.map(n => {\n    var t;\n    return (t = n.split(\"/\")) == null ? void 0 : t[1];\n  }) || [];\n}\nfunction hn(e) {\n  return Buffer.from(JSON.stringify(e)).toString(\"base64\");\n}\nfunction yn(e) {\n  return JSON.parse(Buffer.from(e, \"base64\").toString(\"utf-8\"));\n}\nfunction O(e) {\n  if (!e) throw new Error(\"No recap provided, value is undefined\");\n  if (!e.att) throw new Error(\"No `att` property found\");\n  const n = Object.keys(e.att);\n  if (!(n != null && n.length)) throw new Error(\"No resources found in `att` property\");\n  n.forEach(t => {\n    const r = e.att[t];\n    if (Array.isArray(r)) throw new Error(`Resource must be an object: ${t}`);\n    if (typeof r != \"object\") throw new Error(`Resource must be an object: ${t}`);\n    if (!Object.keys(r).length) throw new Error(`Resource object is empty: ${t}`);\n    Object.keys(r).forEach(o => {\n      const s = r[o];\n      if (!Array.isArray(s)) throw new Error(`Ability limits ${o} must be an array of objects, found: ${s}`);\n      if (!s.length) throw new Error(`Value of ${o} is empty array, must be an array with objects`);\n      s.forEach(i => {\n        if (typeof i != \"object\") throw new Error(`Ability limits (${o}) must be an array of objects, found: ${i}`);\n      });\n    });\n  });\n}\nfunction gn(e, n, t, r = {}) {\n  return t?.sort((o, s) => o.localeCompare(s)), {\n    att: {\n      [e]: pe(n, t, r)\n    }\n  };\n}\nfunction vn(e, n, t) {\n  var r;\n  return e.att[n] = de({}, t), ((r = Object.keys(e.att)) == null ? void 0 : r.sort((o, s) => o.localeCompare(s))).reduce((o, s) => (o.att[s] = e.att[s], o), {\n    att: {}\n  });\n}\nfunction pe(e, n, t = {}) {\n  n = n?.sort((o, s) => o.localeCompare(s));\n  const r = n.map(o => ({\n    [`${e}/${o}`]: [t]\n  }));\n  return Object.assign({}, ...r);\n}\nfunction G(e) {\n  return O(e), `urn:recap:${hn(e).replace(/=/g, \"\")}`;\n}\nfunction I(e) {\n  const n = yn(e.replace(\"urn:recap:\", \"\"));\n  return O(n), n;\n}\nfunction ur(e, n, t) {\n  const r = gn(e, n, t);\n  return G(r);\n}\nfunction me(e) {\n  return e && e.includes(\"urn:recap:\");\n}\nfunction lr(e, n) {\n  const t = I(e),\n    r = I(n),\n    o = bn(t, r);\n  return G(o);\n}\nfunction bn(e, n) {\n  O(e), O(n);\n  const t = Object.keys(e.att).concat(Object.keys(n.att)).sort((o, s) => o.localeCompare(s)),\n    r = {\n      att: {}\n    };\n  return t.forEach(o => {\n    var s, i;\n    Object.keys(((s = e.att) == null ? void 0 : s[o]) || {}).concat(Object.keys(((i = n.att) == null ? void 0 : i[o]) || {})).sort((u, l) => u.localeCompare(l)).forEach(u => {\n      var l, c;\n      r.att[o] = an(de({}, r.att[o]), {\n        [u]: ((l = e.att[o]) == null ? void 0 : l[u]) || ((c = n.att[o]) == null ? void 0 : c[u])\n      });\n    });\n  }), r;\n}\nfunction he(e = \"\", n) {\n  O(n);\n  const t = \"I further authorize the stated URI to perform the following actions on my behalf: \";\n  if (e.includes(t)) return e;\n  const r = [];\n  let o = 0;\n  Object.keys(n.att).forEach(u => {\n    const l = Object.keys(n.att[u]).map(a => ({\n      ability: a.split(\"/\")[0],\n      action: a.split(\"/\")[1]\n    }));\n    l.sort((a, f) => a.action.localeCompare(f.action));\n    const c = {};\n    l.forEach(a => {\n      c[a.ability] || (c[a.ability] = []), c[a.ability].push(a.action);\n    });\n    const d = Object.keys(c).map(a => (o++, `(${o}) '${a}': '${c[a].join(\"', '\")}' for '${u}'.`));\n    r.push(d.join(\", \").replace(\".,\", \".\"));\n  });\n  const s = r.join(\" \"),\n    i = `${t}${s}`;\n  return `${e ? e + \" \" : \"\"}${i}`;\n}\nfunction dr(e) {\n  var n;\n  const t = I(e);\n  O(t);\n  const r = (n = t.att) == null ? void 0 : n.eip155;\n  return r ? Object.keys(r).map(o => o.split(\"/\")[1]) : [];\n}\nfunction fr(e) {\n  const n = I(e);\n  O(n);\n  const t = [];\n  return Object.values(n.att).forEach(r => {\n    Object.values(r).forEach(o => {\n      var s;\n      (s = o?.[0]) != null && s.chains && t.push(o[0].chains);\n    });\n  }), [...new Set(t.flat())];\n}\nfunction En(e, n) {\n  if (!n) return e;\n  const t = I(n);\n  return O(t), he(e, t);\n}\nfunction Y(e) {\n  if (!e) return;\n  const n = e?.[e.length - 1];\n  return me(n) ? n : void 0;\n}\nconst ye = \"base10\",\n  g = \"base16\",\n  ge = \"base64pad\",\n  pr = \"base64url\",\n  k = \"utf8\",\n  ve = 0,\n  D = 1,\n  M = 2,\n  mr = 0,\n  wn = 1,\n  K = 12,\n  be = 32;\nfunction hr() {\n  const e = _e.generateKeyPair();\n  return {\n    privateKey: v(e.secretKey, g),\n    publicKey: v(e.publicKey, g)\n  };\n}\nfunction yr() {\n  const e = B(be);\n  return v(e, g);\n}\nfunction gr(e, n) {\n  const t = _e.sharedKey(w(e, g), w(n, g), !0),\n    r = new at(Ce, t).expand(be);\n  return v(r, g);\n}\nfunction vr(e) {\n  const n = Ue(w(e, g));\n  return v(n, g);\n}\nfunction br(e) {\n  const n = Ue(w(e, k));\n  return v(n, g);\n}\nfunction Ee(e) {\n  return w(`${e}`, ye);\n}\nfunction C(e) {\n  return Number(v(e, ye));\n}\nfunction Er(e) {\n  const n = Ee(typeof e.type < \"u\" ? e.type : ve);\n  if (C(n) === D && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? w(e.senderPublicKey, g) : void 0,\n    r = typeof e.iv < \"u\" ? w(e.iv, g) : B(K),\n    o = new Ae(w(e.symKey, g)).seal(r, w(e.message, k));\n  return we({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t,\n    encoding: e.encoding\n  });\n}\nfunction wr(e, n) {\n  const t = Ee(M),\n    r = B(K),\n    o = w(e, k);\n  return we({\n    type: t,\n    sealed: o,\n    iv: r,\n    encoding: n\n  });\n}\nfunction Or(e) {\n  const n = new Ae(w(e.symKey, g)),\n    {\n      sealed: t,\n      iv: r\n    } = Q({\n      encoded: e.encoded,\n      encoding: e?.encoding\n    }),\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return v(o, k);\n}\nfunction Nr(e, n) {\n  const {\n    sealed: t\n  } = Q({\n    encoded: e,\n    encoding: n\n  });\n  return v(t, k);\n}\nfunction we(e) {\n  const {\n    encoding: n = ge\n  } = e;\n  if (C(e.type) === M) return v(te([e.type, e.sealed]), n);\n  if (C(e.type) === D) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return v(te([e.type, e.senderPublicKey, e.iv, e.sealed]), n);\n  }\n  return v(te([e.type, e.iv, e.sealed]), n);\n}\nfunction Q(e) {\n  const {\n      encoded: n,\n      encoding: t = ge\n    } = e,\n    r = w(n, t),\n    o = r.slice(mr, wn),\n    s = wn;\n  if (C(o) === D) {\n    const c = s + be,\n      d = c + K,\n      a = r.slice(s, c),\n      f = r.slice(c, d),\n      h = r.slice(d);\n    return {\n      type: o,\n      sealed: h,\n      iv: f,\n      senderPublicKey: a\n    };\n  }\n  if (C(o) === M) {\n    const c = r.slice(s),\n      d = B(K);\n    return {\n      type: o,\n      sealed: c,\n      iv: d\n    };\n  }\n  const i = s + K,\n    u = r.slice(s, i),\n    l = r.slice(i);\n  return {\n    type: o,\n    sealed: l,\n    iv: u\n  };\n}\nfunction Sr(e, n) {\n  const t = Q({\n    encoded: e,\n    encoding: n?.encoding\n  });\n  return On({\n    type: C(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? v(t.senderPublicKey, g) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\nfunction On(e) {\n  const n = e?.type || ve;\n  if (n === D) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\nfunction $r(e) {\n  return e.type === D && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nfunction Rr(e) {\n  return e.type === M;\n}\nfunction Nn(e) {\n  return new ut(\"p256\").keyFromPublic({\n    x: Buffer.from(e.x, \"base64\").toString(\"hex\"),\n    y: Buffer.from(e.y, \"base64\").toString(\"hex\")\n  }, \"hex\");\n}\nfunction Ir(e) {\n  let n = e.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const t = n.length % 4;\n  return t > 0 && (n += \"=\".repeat(4 - t)), n;\n}\nfunction Pr(e) {\n  return Buffer.from(Ir(e), \"base64\");\n}\nfunction jr(e, n) {\n  const [t, r, o] = e.split(\".\"),\n    s = Pr(o);\n  if (s.length !== 64) throw new Error(\"Invalid signature length\");\n  const i = s.slice(0, 32).toString(\"hex\"),\n    u = s.slice(32, 64).toString(\"hex\"),\n    l = `${t}.${r}`,\n    c = new Ce().update(Buffer.from(l)).digest(),\n    d = Nn(n),\n    a = Buffer.from(c).toString(\"hex\");\n  if (!d.verify(a, {\n    r: i,\n    s: u\n  })) throw new Error(\"Invalid signature\");\n  return lt(e).payload;\n}\nconst Sn = \"irn\";\nfunction Tr(e) {\n  return e?.relay || {\n    protocol: Sn\n  };\n}\nfunction Ar(e) {\n  const n = dt[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\nvar Cr = Object.defineProperty,\n  Ur = Object.defineProperties,\n  _r = Object.getOwnPropertyDescriptors,\n  $n = Object.getOwnPropertySymbols,\n  kr = Object.prototype.hasOwnProperty,\n  Dr = Object.prototype.propertyIsEnumerable,\n  Rn = (e, n, t) => n in e ? Cr(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  In = (e, n) => {\n    for (var t in n || (n = {})) kr.call(n, t) && Rn(e, t, n[t]);\n    if ($n) for (var t of $n(n)) Dr.call(n, t) && Rn(e, t, n[t]);\n    return e;\n  },\n  xr = (e, n) => Ur(e, _r(n));\nfunction Pn(e, n = \"-\") {\n  const t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n        i = e[o];\n      t[s] = i;\n    }\n  }), t;\n}\nfunction Vr(e) {\n  if (!e.includes(\"wc:\")) {\n    const l = le(e);\n    l != null && l.includes(\"wc:\") && (e = l);\n  }\n  e = e.includes(\"wc://\") ? e.replace(\"wc://\", \"\") : e, e = e.includes(\"wc:\") ? e.replace(\"wc:\", \"\") : e;\n  const n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    s = typeof t < \"u\" ? e.substring(t) : \"\",\n    i = q.parse(s),\n    u = typeof i.methods == \"string\" ? i.methods.split(\",\") : void 0;\n  return {\n    protocol: r,\n    topic: jn(o[0]),\n    version: parseInt(o[1], 10),\n    symKey: i.symKey,\n    relay: Pn(i),\n    methods: u,\n    expiryTimestamp: i.expiryTimestamp ? parseInt(i.expiryTimestamp, 10) : void 0\n  };\n}\nfunction jn(e) {\n  return e.startsWith(\"//\") ? e.substring(2) : e;\n}\nfunction Tn(e, n = \"-\") {\n  const t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(o => {\n    const s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\nfunction Mr(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + q.stringify(In(xr(In({\n    symKey: e.symKey\n  }, Tn(e.relay)), {\n    expiryTimestamp: e.expiryTimestamp\n  }), e.methods ? {\n    methods: e.methods.join(\",\")\n  } : {}));\n}\nfunction Kr(e, n, t) {\n  return `${e}?wc_ev=${t}&topic=${n}`;\n}\nvar Lr = Object.defineProperty,\n  Fr = Object.defineProperties,\n  qr = Object.getOwnPropertyDescriptors,\n  An = Object.getOwnPropertySymbols,\n  Br = Object.prototype.hasOwnProperty,\n  Hr = Object.prototype.propertyIsEnumerable,\n  Cn = (e, n, t) => n in e ? Lr(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Wr = (e, n) => {\n    for (var t in n || (n = {})) Br.call(n, t) && Cn(e, t, n[t]);\n    if (An) for (var t of An(n)) Hr.call(n, t) && Cn(e, t, n[t]);\n    return e;\n  },\n  Jr = (e, n) => Fr(e, qr(n));\nfunction U(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\nfunction Un(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...U(t.accounts));\n  }), n;\n}\nfunction _n(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    U(r.accounts).includes(n) && t.push(...r.methods);\n  }), t;\n}\nfunction kn(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    U(r.accounts).includes(n) && t.push(...r.events);\n  }), t;\n}\nfunction zr(e, n) {\n  const t = Wn(e, n);\n  if (t) throw new Error(t.message);\n  const r = {};\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(i => `${i.split(\":\")[0]}:${i.split(\":\")[1]}`)\n  };\n  return r;\n}\nfunction Gr(e) {\n  const {\n      proposal: {\n        requiredNamespaces: n,\n        optionalNamespaces: t = {}\n      },\n      supportedNamespaces: r\n    } = e,\n    o = Ne(n),\n    s = Ne(t),\n    i = {};\n  Object.keys(r).forEach(c => {\n    const d = r[c].chains,\n      a = r[c].methods,\n      f = r[c].events,\n      h = r[c].accounts;\n    d.forEach(p => {\n      if (!h.some(m => m.includes(p))) throw new Error(`No accounts provided for chain ${p} in namespace ${c}`);\n    }), i[c] = {\n      chains: d,\n      methods: a,\n      events: f,\n      accounts: h\n    };\n  });\n  const u = zn(n, i, \"approve()\");\n  if (u) throw new Error(u.message);\n  const l = {};\n  return !Object.keys(n).length && !Object.keys(t).length ? i : (Object.keys(o).forEach(c => {\n    const d = r[c].chains.filter(p => {\n        var m, E;\n        return (E = (m = o[c]) == null ? void 0 : m.chains) == null ? void 0 : E.includes(p);\n      }),\n      a = r[c].methods.filter(p => {\n        var m, E;\n        return (E = (m = o[c]) == null ? void 0 : m.methods) == null ? void 0 : E.includes(p);\n      }),\n      f = r[c].events.filter(p => {\n        var m, E;\n        return (E = (m = o[c]) == null ? void 0 : m.events) == null ? void 0 : E.includes(p);\n      }),\n      h = d.map(p => r[c].accounts.filter(m => m.includes(`${p}:`))).flat();\n    l[c] = {\n      chains: d,\n      methods: a,\n      events: f,\n      accounts: h\n    };\n  }), Object.keys(s).forEach(c => {\n    var d, a, f, h, p, m;\n    if (!r[c]) return;\n    const E = (a = (d = s[c]) == null ? void 0 : d.chains) == null ? void 0 : a.filter(j => r[c].chains.includes(j)),\n      nt = r[c].methods.filter(j => {\n        var T, x;\n        return (x = (T = s[c]) == null ? void 0 : T.methods) == null ? void 0 : x.includes(j);\n      }),\n      tt = r[c].events.filter(j => {\n        var T, x;\n        return (x = (T = s[c]) == null ? void 0 : T.events) == null ? void 0 : x.includes(j);\n      }),\n      rt = E?.map(j => r[c].accounts.filter(T => T.includes(`${j}:`))).flat();\n    l[c] = {\n      chains: N((f = l[c]) == null ? void 0 : f.chains, E),\n      methods: N((h = l[c]) == null ? void 0 : h.methods, nt),\n      events: N((p = l[c]) == null ? void 0 : p.events, tt),\n      accounts: N((m = l[c]) == null ? void 0 : m.accounts, rt)\n    };\n  }), l);\n}\nfunction Oe(e) {\n  return e.includes(\":\");\n}\nfunction Dn(e) {\n  return Oe(e) ? e.split(\":\")[0] : e;\n}\nfunction Ne(e) {\n  var n, t, r;\n  const o = {};\n  if (!Z(e)) return o;\n  for (const [s, i] of Object.entries(e)) {\n    const u = Oe(s) ? [s] : i.chains,\n      l = i.methods || [],\n      c = i.events || [],\n      d = Dn(s);\n    o[d] = Jr(Wr({}, o[d]), {\n      chains: N(u, (n = o[d]) == null ? void 0 : n.chains),\n      methods: N(l, (t = o[d]) == null ? void 0 : t.methods),\n      events: N(c, (r = o[d]) == null ? void 0 : r.events)\n    });\n  }\n  return o;\n}\nfunction xn(e) {\n  const n = {};\n  return e?.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n[r] || (n[r] = {\n      accounts: [],\n      chains: [],\n      events: []\n    }), n[r].accounts.push(t), n[r].chains.push(`${r}:${o}`);\n  }), n;\n}\nfunction Yr(e, n) {\n  n = n.map(r => r.replace(\"did:pkh:\", \"\"));\n  const t = xn(n);\n  for (const [r, o] of Object.entries(t)) o.methods ? o.methods = N(o.methods, e) : o.methods = e, o.events = [\"chainChanged\", \"accountsChanged\"];\n  return t;\n}\nconst Vn = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  Mn = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction S(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Mn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction _(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Vn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction L(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction Z(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction P(e) {\n  return typeof e > \"u\";\n}\nfunction b(e, n) {\n  return n && P(e) ? !0 : typeof e == \"string\" && !!e.trim().length;\n}\nfunction X(e, n) {\n  return n && P(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction Qr(e, n) {\n  const {\n      requiredNamespaces: t\n    } = n,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  let s = !0;\n  return R(o, r) ? (r.forEach(i => {\n    const {\n        accounts: u,\n        methods: l,\n        events: c\n      } = e.namespaces[i],\n      d = U(u),\n      a = t[i];\n    (!R(W(i, a), d) || !R(a.methods, l) || !R(a.events, c)) && (s = !1);\n  }), s) : !1;\n}\nfunction F(e) {\n  return b(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction Kn(e) {\n  if (b(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && F(t);\n    }\n  }\n  return !1;\n}\nfunction Zr(e) {\n  function n(t) {\n    try {\n      return typeof new URL(t) < \"u\";\n    } catch {\n      return !1;\n    }\n  }\n  try {\n    if (b(e, !1)) {\n      if (n(e)) return !0;\n      const t = le(e);\n      return n(t);\n    }\n  } catch {}\n  return !1;\n}\nfunction Xr(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\nfunction eo(e) {\n  return e?.topic;\n}\nfunction no(e, n) {\n  let t = null;\n  return b(e?.publicKey, !1) || (t = S(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\nfunction Se(e) {\n  let n = !0;\n  return L(e) ? e.length && (n = e.every(t => b(t, !1))) : n = !1, n;\n}\nfunction Ln(e, n, t) {\n  let r = null;\n  return L(n) && n.length ? n.forEach(o => {\n    r || F(o) || (r = _(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : F(e) || (r = _(\"UNSUPPORTED_CHAINS\", `${t}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`)), r;\n}\nfunction Fn(e, n, t) {\n  let r = null;\n  return Object.entries(e).forEach(([o, s]) => {\n    if (r) return;\n    const i = Ln(o, W(o, s), `${n} ${t}`);\n    i && (r = i);\n  }), r;\n}\nfunction qn(e, n) {\n  let t = null;\n  return L(e) ? e.forEach(r => {\n    t || Kn(r) || (t = _(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = _(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction Bn(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = qn(r?.accounts, `${n} namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction Hn(e, n) {\n  let t = null;\n  return Se(e?.methods) ? Se(e?.events) || (t = _(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = _(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction $e(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = Hn(r, `${n}, namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction to(e, n, t) {\n  let r = null;\n  if (e && Z(e)) {\n    const o = $e(e, n);\n    o && (r = o);\n    const s = Fn(e, n, t);\n    s && (r = s);\n  } else r = S(\"MISSING_OR_INVALID\", `${n}, ${t} should be an object with data`);\n  return r;\n}\nfunction Wn(e, n) {\n  let t = null;\n  if (e && Z(e)) {\n    const r = $e(e, n);\n    r && (t = r);\n    const o = Bn(e, n);\n    o && (t = o);\n  } else t = S(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n  return t;\n}\nfunction Jn(e) {\n  return b(e.protocol, !0);\n}\nfunction ro(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && L(e) && e.length && e.forEach(r => {\n    t = Jn(r);\n  }), t;\n}\nfunction oo(e) {\n  return typeof e == \"number\";\n}\nfunction so(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction io(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !X(e.code, !1) || !e.message || !b(e.message, !1));\n}\nfunction co(e) {\n  return !(P(e) || !b(e.method, !1));\n}\nfunction ao(e) {\n  return !(P(e) || P(e.result) && P(e.error) || !X(e.id, !1) || !b(e.jsonrpc, !1));\n}\nfunction uo(e) {\n  return !(P(e) || !b(e.name, !1));\n}\nfunction lo(e, n) {\n  return !(!F(n) || !Un(e).includes(n));\n}\nfunction fo(e, n, t) {\n  return b(t, !1) ? _n(e, n).includes(t) : !1;\n}\nfunction po(e, n, t) {\n  return b(t, !1) ? kn(e, n).includes(t) : !1;\n}\nfunction zn(e, n, t) {\n  let r = null;\n  const o = mo(e),\n    s = ho(n),\n    i = Object.keys(o),\n    u = Object.keys(s),\n    l = Gn(Object.keys(e)),\n    c = Gn(Object.keys(n)),\n    d = l.filter(a => !c.includes(a));\n  return d.length && (r = S(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${d.toString()}\n      Received: ${Object.keys(n).toString()}`)), R(i, u) || (r = S(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${i.toString()}\n      Approved: ${u.toString()}`)), Object.keys(n).forEach(a => {\n    if (!a.includes(\":\") || r) return;\n    const f = U(n[a].accounts);\n    f.includes(a) || (r = S(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${a}\n        Required: ${a}\n        Approved: ${f.toString()}`));\n  }), i.forEach(a => {\n    r || (R(o[a].methods, s[a].methods) ? R(o[a].events, s[a].events) || (r = S(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${a}`)) : r = S(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${a}`));\n  }), r;\n}\nfunction mo(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    var r;\n    t.includes(\":\") ? n[t] = e[t] : (r = e[t].chains) == null || r.forEach(o => {\n      n[o] = {\n        methods: e[t].methods,\n        events: e[t].events\n      };\n    });\n  }), n;\n}\nfunction Gn(e) {\n  return [...new Set(e.map(n => n.includes(\":\") ? n.split(\":\")[0] : n))];\n}\nfunction ho(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    if (t.includes(\":\")) n[t] = e[t];else {\n      const r = U(e[t].accounts);\n      r?.forEach(o => {\n        n[o] = {\n          accounts: e[t].accounts.filter(s => s.includes(`${o}:`)),\n          methods: e[t].methods,\n          events: e[t].events\n        };\n      });\n    }\n  }), n;\n}\nfunction yo(e, n) {\n  return X(e, !1) && e <= n.max && e >= n.min;\n}\nfunction go() {\n  const e = A();\n  return new Promise(n => {\n    switch (e) {\n      case y.browser:\n        n(Yn());\n        break;\n      case y.reactNative:\n        n(Qn());\n        break;\n      case y.node:\n        n(Zn());\n        break;\n      default:\n        n(!0);\n    }\n  });\n}\nfunction Yn() {\n  return V() && navigator?.onLine;\n}\nasync function Qn() {\n  if ($() && typeof global < \"u\" && global != null && global.NetInfo) {\n    const e = await (global == null ? void 0 : global.NetInfo.fetch());\n    return e?.isConnected;\n  }\n  return !0;\n}\nfunction Zn() {\n  return !0;\n}\nfunction vo(e) {\n  switch (A()) {\n    case y.browser:\n      Xn(e);\n      break;\n    case y.reactNative:\n      et(e);\n      break;\n    case y.node:\n      break;\n  }\n}\nfunction Xn(e) {\n  !$() && V() && (window.addEventListener(\"online\", () => e(!0)), window.addEventListener(\"offline\", () => e(!1)));\n}\nfunction et(e) {\n  $() && typeof global < \"u\" && global != null && global.NetInfo && global?.NetInfo.addEventListener(n => e(n?.isConnected));\n}\nconst Re = {};\nclass bo {\n  static get(n) {\n    return Re[n];\n  }\n  static set(n, t) {\n    Re[n] = t;\n  }\n  static delete(n) {\n    delete Re[n];\n  }\n}\nexport { ye as BASE10, g as BASE16, ge as BASE64, pr as BASE64URL, Et as COLON, ie as DEFAULT_DEPTH, J as EMPTY_SPACE, y as ENV_MAP, Mn as INTERNAL_ERRORS, bo as MemoryStore, wt as ONE_THOUSAND, qe as REACT_NATIVE_PRODUCT, Sn as RELAYER_DEFAULT_PROTOCOL, Vn as SDK_ERRORS, He as SDK_TYPE, Be as SLASH, ve as TYPE_0, D as TYPE_1, M as TYPE_2, k as UTF8, vn as addResourceToRecap, We as appendToQueryString, jt as assertType, pe as assignAbilityToActions, yn as base64Decode, hn as base64Encode, Gr as buildApprovedNamespaces, sr as buildAuthObject, Yr as buildNamespacesFromAuth, En as buildRecapStatement, Lt as calcExpiry, kt as capitalize, Ze as capitalizeWord, Dt as createDelayedPromise, ur as createEncodedRecap, xt as createExpiringPromise, gn as createRecap, I as decodeRecap, C as decodeTypeByte, Nr as decodeTypeTwoEnvelope, Or as decrypt, gr as deriveSymKey, Q as deserialize, G as encodeRecap, Ee as encodeTypeByte, wr as encodeTypeTwoEnvelope, Er as encrypt, qt as engineEvent, _t as enumify, De as formatAccountId, ft as formatAccountWithChain, ke as formatChainId, Xe as formatDeeplinkUrl, ae as formatExpirerTarget, Mt as formatIdTarget, dn as formatMessage, Tt as formatMessageContext, Tn as formatRelayParams, It as formatRelayRpcUrl, he as formatStatementFromRecap, Vt as formatTopicTarget, Ge as formatUA, Mr as formatUri, le as fromBase64, hr as generateKeyPair, yr as generateRandomBytes32, U as getAccountsChains, mt as getAccountsFromNamespaces, xe as getAddressFromAccount, pt as getAddressesFromAccounts, St as getAppId, $t as getAppMetadata, Yn as getBrowserOnlineStatus, Ve as getChainFromAccount, Me as getChainsFromAccounts, W as getChainsFromNamespace, ht as getChainsFromNamespaces, fr as getChainsFromRecap, yt as getChainsFromRequiredNamespaces, ue as getCommonValuesInArrays, Nn as getCryptoKeyFromKeyData, fn as getDecodedRecapFromResources, Ht as getDeepLink, fe as getDidAddress, z as getDidAddressSegments, un as getDidChainId, A as getEnvironment, Pt as getHttpUrl, S as getInternalError, ze as getJavascriptID, Je as getJavascriptOS, Qe as getLastItems, Kr as getLinkModeURL, dr as getMethodsFromRecap, ln as getNamespacedDidChainId, Un as getNamespacesChains, kn as getNamespacesEventsForChainId, xn as getNamespacesFromAccounts, _n as getNamespacesMethodsForChainId, Zn as getNodeOnlineStatus, mn as getReCapActions, Qn as getReactNativeOnlineStatus, ar as getRecapAbilitiesFromResource, Y as getRecapFromResources, pn as getRecapResource, Rt as getRelayClientMetadata, Ar as getRelayProtocolApi, Tr as getRelayProtocolName, zr as getRequiredNamespacesFromNamespaces, _ as getSdkError, Wt as getSearchParamFromURL, se as getUniqueValues, Bt as handleDeeplinkRedirect, R as hasOverlap, vr as hashKey, br as hashMessage, Ot as isAndroid, V as isBrowser, Oe as isCaipNamespace, zn as isConformingNamespaces, Ft as isExpired, Nt as isIos, ce as isNode, go as isOnline, Xr as isProposalStruct, $ as isReactNative, me as isRecap, Qr as isSessionCompatible, eo as isSessionStruct, en as isTelegram, zt as isTestRun, $r as isTypeOneEnvelope, Rr as isTypeTwoEnvelope, P as isUndefined, Kn as isValidAccountId, qn as isValidAccounts, Hn as isValidActions, L as isValidArray, F as isValidChainId, Ln as isValidChains, no as isValidController, on as isValidEip1271Signature, rn as isValidEip191Signature, io as isValidErrorReason, uo as isValidEvent, oo as isValidId, Bn as isValidNamespaceAccounts, $e as isValidNamespaceActions, Fn as isValidNamespaceChains, Se as isValidNamespaceMethodsOrEvents, Wn as isValidNamespaces, lo as isValidNamespacesChainId, po as isValidNamespacesEvent, fo as isValidNamespacesRequest, X as isValidNumber, Z as isValidObject, so as isValidParams, O as isValidRecap, Jn as isValidRelay, ro as isValidRelays, co as isValidRequest, yo as isValidRequestExpiry, to as isValidRequiredNamespaces, ao as isValidResponse, b as isValidString, Zr as isValidUrl, Ut as mapEntries, At as mapToObj, N as mergeArrays, lr as mergeEncodedRecaps, bn as mergeRecaps, Ne as normalizeNamespaces, Ct as objToMap, oe as parseAccountId, re as parseChainId, Ye as parseContextNames, Kt as parseExpirerTarget, Dn as parseNamespaceKey, Pn as parseRelayParams, jn as parseTopic, Vr as parseUri, ir as populateAuthPayload, cr as recapHasResource, we as serialize, Gt as sleep, Xn as subscribeToBrowserNetworkChange, vo as subscribeToNetworkChange, et as subscribeToReactNativeNetworkChange, nn as toBase64, Jt as uuidv4, Sr as validateDecoding, On as validateEncoding, or as validateSignedCacao, jr as verifyP256Jwt, tn as verifySignature };","map":{"version":3,"names":[],"sources":["D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\caip.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\misc.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\signatures.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\cacao.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\crypto.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\relay.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\uri.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\namespaces.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\errors.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\validators.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\network.ts","D:\\Carlosverbelen.online\\token\\node_modules\\@walletconnect\\utils\\src\\memoryStore.ts"],"sourcesContent":["import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...getChainsFromNamespace(key, ns));\n  });\n  return chains;\n}\n\nexport function getChainsFromNamespace(\n  namespace: string,\n  namespaceProps: ProposalTypes.BaseRequiredNamespace,\n) {\n  // check if chainId is provided in the key as `eip155:1` or in the namespace as chains[]\n  return namespace.includes(\":\") ? [namespace] : namespaceProps.chains || [];\n}\n","import { detect } from \"detect-browser\";\nimport { FIVE_MINUTES, fromMiliseconds, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  SignClientTypes,\n  RelayerClientMetadata,\n  EngineTypes,\n  RelayerTypes,\n} from \"@walletconnect/types\";\nimport { getDocument, getLocation, getNavigator } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata } from \"@walletconnect/window-metadata\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-utils\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\nimport * as qs from \"query-string\";\n\n// -- constants -----------------------------------------//\nexport const REACT_NATIVE_PRODUCT = \"ReactNative\";\n\nexport const ENV_MAP = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\",\n};\n\nexport const EMPTY_SPACE = \" \";\n\nexport const COLON = \":\";\n\nexport const SLASH = \"/\";\n\nexport const DEFAULT_DEPTH = 2;\n\nexport const ONE_THOUSAND = 1000;\n\nexport const SDK_TYPE = \"js\";\n\n// -- env -----------------------------------------------//\n\nexport function isNode(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\"\n  );\n}\n\nexport function isReactNative(): boolean {\n  return !getDocument() && !!getNavigator() && navigator.product === REACT_NATIVE_PRODUCT;\n}\n\nexport function isAndroid(): boolean {\n  return (\n    isReactNative() &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\" &&\n    (global as any)?.Platform.OS === \"android\"\n  );\n}\n\nexport function isIos(): boolean {\n  return (\n    isReactNative() &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\" &&\n    (global as any)?.Platform.OS === \"ios\"\n  );\n}\n\nexport function isBrowser(): boolean {\n  return !isNode() && !!getNavigator() && !!getDocument();\n}\n\nexport function getEnvironment(): string {\n  if (isReactNative()) return ENV_MAP.reactNative;\n  if (isNode()) return ENV_MAP.node;\n  if (isBrowser()) return ENV_MAP.browser;\n  return ENV_MAP.unknown;\n}\n\nexport function getAppId(): string | undefined {\n  try {\n    if (\n      isReactNative() &&\n      typeof global !== \"undefined\" &&\n      typeof (global as any)?.Application !== \"undefined\"\n    ) {\n      return (global as any).Application?.applicationId;\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n// -- query -----------------------------------------------//\n\nexport function appendToQueryString(queryString: string, newQueryParams: any): string {\n  let queryParams = qs.parse(queryString);\n\n  queryParams = { ...queryParams, ...newQueryParams };\n\n  queryString = qs.stringify(queryParams);\n\n  return queryString;\n}\n\n// -- metadata ----------------------------------------------//\n\nexport function getAppMetadata(): SignClientTypes.Metadata {\n  return (\n    getWindowMetadata() || {\n      name: \"\",\n      description: \"\",\n      url: \"\",\n      icons: [\"\"],\n    }\n  );\n}\n\nexport function getRelayClientMetadata(protocol: string, version: number): RelayerClientMetadata {\n  const env = getEnvironment();\n\n  const metadata: RelayerClientMetadata = { protocol, version, env };\n  if (env === \"browser\") {\n    metadata.host = getLocation()?.host || \"unknown\";\n  }\n  return metadata;\n}\n\n// -- rpcUrl ----------------------------------------------//\n\nexport function getJavascriptOS() {\n  const env = getEnvironment();\n  // global.Platform is set by react-native-compat\n  if (\n    env === ENV_MAP.reactNative &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\"\n  ) {\n    const { OS, Version } = (global as any).Platform;\n    return [OS, Version].join(\"-\");\n  }\n\n  const info = detect();\n  if (info === null) return \"unknown\";\n  const os = info.os ? info.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  if (info.type === \"browser\") {\n    return [os, info.name, info.version].join(\"-\");\n  }\n  return [os, info.version].join(\"-\");\n}\n\nexport function getJavascriptID() {\n  const env = getEnvironment();\n  return env === ENV_MAP.browser ? [env, getLocation()?.host || \"unknown\"].join(\":\") : env;\n}\n\nexport function formatUA(protocol: string, version: number, sdkVersion: string) {\n  const os = getJavascriptOS();\n  const id = getJavascriptID();\n  return [[protocol, version].join(\"-\"), [SDK_TYPE, sdkVersion].join(\"-\"), os, id].join(\"/\");\n}\nconsole;\n\nexport function formatRelayRpcUrl({\n  protocol,\n  version,\n  relayUrl,\n  sdkVersion,\n  auth,\n  projectId,\n  useOnCloseEvent,\n  bundleId,\n  packageName,\n}: RelayerTypes.RpcUrlParams) {\n  const splitUrl = relayUrl.split(\"?\");\n  const ua = formatUA(protocol, version, sdkVersion);\n  const params = {\n    auth,\n    ua,\n    projectId,\n    useOnCloseEvent: useOnCloseEvent || undefined,\n    packageName: packageName || undefined,\n    bundleId: bundleId || undefined,\n  };\n  const queryString = appendToQueryString(splitUrl[1] || \"\", params);\n  return splitUrl[0] + \"?\" + queryString;\n}\n\nexport function getHttpUrl(url: string) {\n  // regex from https://stackoverflow.com/questions/3883871/regexp-to-grab-protocol-from-url\n  const matches = url.match(/^[^:]+(?=:\\/\\/)/gi) || [];\n  let protocol = matches[0];\n  const domain = typeof protocol !== \"undefined\" ? url.split(\"://\")[1] : url;\n  protocol = protocol === \"wss\" ? \"https\" : \"http\";\n  return [protocol, domain].join(\"://\");\n}\n\n// -- assert ------------------------------------------------- //\n\nexport function assertType(obj: any, key: string, type: string) {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\n// -- context ------------------------------------------------- //\n\nexport function parseContextNames(context: string, depth = DEFAULT_DEPTH) {\n  return getLastItems(context.split(SLASH), depth);\n}\n\nexport function formatMessageContext(context: string): string {\n  return parseContextNames(context).join(EMPTY_SPACE);\n}\n\n// -- array ------------------------------------------------- //\n\nexport function hasOverlap(a: any[], b: any[]): boolean {\n  const matches = a.filter((x) => b.includes(x));\n  return matches.length === a.length;\n}\n\nexport function getLastItems(arr: any[], depth = DEFAULT_DEPTH): any[] {\n  return arr.slice(Math.max(arr.length - depth, 0));\n}\n\n// -- map ------------------------------------------------- //\n\nexport function mapToObj<T = any>(map: Map<string, T>): Record<string, T> {\n  return Object.fromEntries(map.entries());\n}\n\nexport function objToMap<T = any>(obj: Record<string, T>): Map<string, T> {\n  return new Map<string, T>(Object.entries<T>(obj));\n}\n\nexport function mapEntries<A = any, B = any>(\n  obj: Record<string, A>,\n  cb: (x: A) => B,\n): Record<string, B> {\n  const res = {};\n  Object.keys(obj).forEach((key) => {\n    res[key] = cb(obj[key]);\n  });\n  return res;\n}\n\n// -- enum ------------------------------------------------- //\n\n// source: https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nexport const enumify = <T extends { [index: string]: U }, U extends string>(x: T): T => x;\n\n// -- string ------------------------------------------------- //\n\nexport function capitalizeWord(word: string) {\n  return word.trim().replace(/^\\w/, (c) => c.toUpperCase());\n}\n\nexport function capitalize(str: string) {\n  return str\n    .split(EMPTY_SPACE)\n    .map((w) => capitalizeWord(w))\n    .join(EMPTY_SPACE);\n}\n\n// -- promises --------------------------------------------- //\nexport function createDelayedPromise<T>(\n  expiry: number = FIVE_MINUTES,\n  expireErrorMessage?: string,\n) {\n  const timeout = toMiliseconds(expiry || FIVE_MINUTES);\n  let cacheResolve: undefined | ((value: T | PromiseLike<T>) => void);\n  let cacheReject: undefined | ((value?: ErrorResponse) => void);\n  let cacheTimeout: undefined | NodeJS.Timeout;\n  let result: Promise<Awaited<T>> | Promise<T> | undefined;\n\n  const done = () =>\n    new Promise<T>((promiseResolve, promiseReject) => {\n      if (result) {\n        return promiseResolve(result);\n      }\n      cacheTimeout = setTimeout(() => {\n        const err = new Error(expireErrorMessage);\n        result = Promise.reject(err);\n        promiseReject(err);\n      }, timeout);\n      cacheResolve = promiseResolve;\n      cacheReject = promiseReject;\n    });\n  const resolve = (value?: T) => {\n    if (cacheTimeout && cacheResolve) {\n      clearTimeout(cacheTimeout);\n      cacheResolve(value as T);\n      result = Promise.resolve(value) as Promise<Awaited<T>>;\n    }\n  };\n  const reject = (value?: ErrorResponse) => {\n    if (cacheTimeout && cacheReject) {\n      clearTimeout(cacheTimeout);\n      cacheReject(value);\n    }\n  };\n\n  return {\n    resolve,\n    reject,\n    done,\n  };\n}\n\nexport function createExpiringPromise<T>(\n  promise: Promise<T>,\n  expiry: number,\n  expireErrorMessage?: string,\n) {\n  return new Promise(async (resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error(expireErrorMessage)), expiry);\n    try {\n      const result = await promise;\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    }\n    clearTimeout(timeout);\n  });\n}\n\n// -- expirer --------------------------------------------- //\n\nexport function formatExpirerTarget(type: \"topic\" | \"id\", value: string | number): string {\n  if (typeof value === \"string\" && value.startsWith(`${type}:`)) return value;\n  if (type.toLowerCase() === \"topic\") {\n    if (typeof value !== \"string\")\n      throw new Error(`Value must be \"string\" for expirer target type: topic`);\n    return `topic:${value}`;\n  } else if (type.toLowerCase() === \"id\") {\n    if (typeof value !== \"number\")\n      throw new Error(`Value must be \"number\" for expirer target type: id`);\n    return `id:${value}`;\n  }\n  throw new Error(`Unknown expirer target type: ${type}`);\n}\n\nexport function formatTopicTarget(topic: string): string {\n  return formatExpirerTarget(\"topic\", topic);\n}\n\nexport function formatIdTarget(id: number): string {\n  return formatExpirerTarget(\"id\", id);\n}\n\nexport function parseExpirerTarget(target: string) {\n  const [type, value] = target.split(\":\");\n  const parsed: { id?: number; topic?: string } = { id: undefined, topic: undefined };\n  if (type === \"topic\" && typeof value === \"string\") {\n    parsed.topic = value;\n  } else if (type === \"id\" && Number.isInteger(Number(value))) {\n    parsed.id = Number(value);\n  } else {\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${type}:${value}`);\n  }\n\n  return parsed;\n}\n\nexport function calcExpiry(ttl: number, now?: number): number {\n  return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));\n}\n\nexport function isExpired(expiry: number) {\n  return Date.now() >= toMiliseconds(expiry);\n}\n\n// -- events ---------------------------------------------- //\n\nexport function engineEvent(event: EngineTypes.Event, id?: number | string | undefined) {\n  return `${event}${id ? `:${id}` : \"\"}`;\n}\n\nexport function mergeArrays<T>(a: T[] = [], b: T[] = []): T[] {\n  return [...new Set([...a, ...b])];\n}\n\nexport async function handleDeeplinkRedirect({\n  id,\n  topic,\n  wcDeepLink,\n}: {\n  id: number;\n  topic: string;\n  wcDeepLink: string;\n}) {\n  try {\n    if (!wcDeepLink) return;\n\n    const json = typeof wcDeepLink === \"string\" ? JSON.parse(wcDeepLink) : wcDeepLink;\n    const deeplink = json?.href;\n    if (typeof deeplink !== \"string\") return;\n    const link = formatDeeplinkUrl(deeplink, id, topic);\n    const env = getEnvironment();\n\n    if (env === ENV_MAP.browser) {\n      if (!getDocument()?.hasFocus()) {\n        console.warn(\"Document does not have focus, skipping deeplink.\");\n        return;\n      }\n\n      if (link.startsWith(\"https://\") || link.startsWith(\"http://\")) {\n        window.open(link, \"_blank\", \"noreferrer noopener\");\n      } else {\n        window.open(link, isTelegram() ? \"_blank\" : \"_self\", \"noreferrer noopener\");\n      }\n    } else if (env === ENV_MAP.reactNative) {\n      // global.Linking is set by react-native-compat\n      if (typeof (global as any)?.Linking !== \"undefined\") {\n        await (global as any).Linking.openURL(link);\n      }\n    }\n  } catch (err) {\n    // Silent error, just log in console\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n}\n\nexport function formatDeeplinkUrl(deeplink: string, requestId: number, sessionTopic: string) {\n  const payload = `requestId=${requestId}&sessionTopic=${sessionTopic}`;\n  if (deeplink.endsWith(\"/\")) deeplink = deeplink.slice(0, -1);\n  let link = `${deeplink}`;\n  if (deeplink.startsWith(\"https://t.me\")) {\n    const startApp = deeplink.includes(\"?\") ? \"&startapp=\" : \"?startapp=\";\n    link = `${link}${startApp}${toBase64(payload, true)}`;\n  } else {\n    link = `${link}/wc?${payload}`;\n  }\n  return link;\n}\n\nexport async function getDeepLink(storage: IKeyValueStorage, key: string) {\n  let link: string | undefined = \"\";\n  try {\n    if (isBrowser()) {\n      link = localStorage.getItem(key) as string;\n      if (link) return link;\n    }\n    link = await storage.getItem(key);\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n  return link;\n}\n\nexport function getCommonValuesInArrays<T = string | number | boolean>(arr1: T[], arr2: T[]): T[] {\n  return arr1.filter((value) => arr2.includes(value));\n}\n\nexport function getSearchParamFromURL(url: string, param: any) {\n  const include = url.includes(param);\n  if (!include) return null;\n  const params = url.split(/([&,?,=])/);\n  const index = params.indexOf(param);\n  const value = params[index + 2];\n  return value;\n}\n\nexport function uuidv4() {\n  if (typeof crypto !== \"undefined\" && crypto?.randomUUID) {\n    return crypto.randomUUID();\n  }\n\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/gu, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n\n    return v.toString(16);\n  });\n}\n\nexport function isTestRun() {\n  return typeof process !== \"undefined\" && process.env.IS_VITEST === \"true\";\n}\n\nexport function isTelegram() {\n  return (\n    typeof window !== \"undefined\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (Boolean((window as any).TelegramWebviewProxy) ||\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      Boolean((window as any).Telegram) ||\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      Boolean((window as any).TelegramWebviewProxyProto))\n  );\n}\n\nexport function toBase64(input: string, removePadding = false): string {\n  const encoded = Buffer.from(input).toString(\"base64\");\n  return removePadding ? encoded.replace(/[=]/g, \"\") : encoded;\n}\n\nexport function fromBase64(encodedString: string): string {\n  return Buffer.from(encodedString, \"base64\").toString(\"utf-8\");\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","import { hashMessage } from \"@ethersproject/hash\";\nimport { recoverAddress } from \"@ethersproject/transactions\";\nimport { AuthTypes } from \"@walletconnect/types\";\nimport { parseChainId } from \"./caip\";\nconst DEFAULT_RPC_URL = \"https://rpc.walletconnect.org/v1\";\n\nexport async function verifySignature(\n  address: string,\n  reconstructedMessage: string,\n  cacaoSignature: AuthTypes.CacaoSignature,\n  chainId: string,\n  projectId: string,\n  baseRpcUrl?: string,\n): Promise<boolean> {\n  // Determine if this signature is from an EOA or a contract.\n  switch (cacaoSignature.t) {\n    case \"eip191\":\n      return isValidEip191Signature(address, reconstructedMessage, cacaoSignature.s);\n    case \"eip1271\":\n      return await isValidEip1271Signature(\n        address,\n        reconstructedMessage,\n        cacaoSignature.s,\n        chainId,\n        projectId,\n        baseRpcUrl,\n      );\n      break;\n    default:\n      throw new Error(\n        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${cacaoSignature.t}`,\n      );\n  }\n}\n\nexport function isValidEip191Signature(\n  address: string,\n  message: string,\n  signature: string,\n): boolean {\n  const recoveredAddress = recoverAddress(hashMessage(message), signature);\n  return recoveredAddress.toLowerCase() === address.toLowerCase();\n}\n\nexport async function isValidEip1271Signature(\n  address: string,\n  reconstructedMessage: string,\n  signature: string,\n  chainId: string,\n  projectId: string,\n  baseRpcUrl?: string,\n) {\n  const parsedChain = parseChainId(chainId);\n  if (!parsedChain.namespace || !parsedChain.reference) {\n    throw new Error(\n      `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${chainId}`,\n    );\n  }\n  try {\n    const eip1271MagicValue = \"0x1626ba7e\";\n    const dynamicTypeOffset = \"0000000000000000000000000000000000000000000000000000000000000040\";\n    const dynamicTypeLength = \"0000000000000000000000000000000000000000000000000000000000000041\";\n    const nonPrefixedSignature = signature.substring(2);\n    const nonPrefixedHashedMessage = hashMessage(reconstructedMessage).substring(2);\n\n    const data =\n      eip1271MagicValue +\n      nonPrefixedHashedMessage +\n      dynamicTypeOffset +\n      dynamicTypeLength +\n      nonPrefixedSignature;\n    const response = await fetch(\n      `${baseRpcUrl || DEFAULT_RPC_URL}/?chainId=${chainId}&projectId=${projectId}`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          id: generateJsonRpcId(),\n          jsonrpc: \"2.0\",\n          method: \"eth_call\",\n          params: [{ to: address, data }, \"latest\"],\n        }),\n      },\n    );\n    const { result } = await response.json();\n    if (!result) return false;\n\n    // Remove right-padded zeros from result to get only the concrete recovered value.\n    const recoveredValue = result.slice(0, eip1271MagicValue.length);\n    return recoveredValue.toLowerCase() === eip1271MagicValue.toLowerCase();\n  } catch (error: any) {\n    // eslint-disable-next-line no-console\n    console.error(\"isValidEip1271Signature: \", error);\n    return false;\n  }\n}\n\nfunction generateJsonRpcId() {\n  return Date.now() + Math.floor(Math.random() * 1000);\n}\n","import { AuthTypes } from \"@walletconnect/types\";\nimport { getCommonValuesInArrays } from \"./misc\";\nimport { verifySignature } from \"./signatures\";\nconst didPrefix = \"did:pkh:\";\nexport const getDidAddressSegments = (iss: string) => {\n  return iss?.split(\":\");\n};\n\nexport const getDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return iss.includes(didPrefix) ? segments[3] : segments[1];\n  }\n  return undefined;\n};\n\nexport const getNamespacedDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[2] + \":\" + segments[3];\n  }\n  return undefined;\n};\n\nexport const getDidAddress = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments.pop();\n  }\n  return undefined;\n};\n\nexport async function validateSignedCacao(params: { cacao: AuthTypes.Cacao; projectId?: string }) {\n  const { cacao, projectId } = params;\n  const { s: signature, p: payload } = cacao;\n  const reconstructed = formatMessage(payload, payload.iss);\n  const walletAddress = getDidAddress(payload.iss) as string;\n  const isValid = await verifySignature(\n    walletAddress,\n    reconstructed,\n    signature,\n    getNamespacedDidChainId(payload.iss) as string,\n    projectId as string,\n  );\n\n  return isValid;\n}\n\nexport const formatMessage = (cacao: AuthTypes.FormatMessageParams, iss: string) => {\n  const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;\n  const walletAddress = getDidAddress(iss);\n\n  if (!cacao.aud && !cacao.uri) {\n    throw new Error(\"Either `aud` or `uri` is required to construct the message\");\n  }\n\n  let statement = cacao.statement || undefined;\n  const uri = `URI: ${cacao.aud || cacao.uri}`;\n  const version = `Version: ${cacao.version}`;\n  const chainId = `Chain ID: ${getDidChainId(iss)}`;\n  const nonce = `Nonce: ${cacao.nonce}`;\n  const issuedAt = `Issued At: ${cacao.iat}`;\n  const expirationTime = cacao.exp ? `Expiration Time: ${cacao.exp}` : undefined;\n  const notBefore = cacao.nbf ? `Not Before: ${cacao.nbf}` : undefined;\n  const requestId = cacao.requestId ? `Request ID: ${cacao.requestId}` : undefined;\n  const resources = cacao.resources\n    ? `Resources:${cacao.resources.map((resource) => `\\n- ${resource}`).join(\"\")}`\n    : undefined;\n  const recap = getRecapFromResources(cacao.resources);\n  if (recap) {\n    const decoded = decodeRecap(recap);\n    statement = formatStatementFromRecap(statement, decoded);\n  }\n\n  const message = [\n    header,\n    walletAddress,\n    ``,\n    statement,\n    ``,\n    uri,\n    version,\n    chainId,\n    nonce,\n    issuedAt,\n    expirationTime,\n    notBefore,\n    requestId,\n    resources,\n  ]\n    .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines\n    .join(\"\\n\");\n\n  return message;\n};\n\nexport function buildAuthObject(\n  requestPayload: AuthTypes.PayloadParams,\n  signature: AuthTypes.CacaoSignature,\n  iss: string,\n) {\n  if (!iss.includes(\"did:pkh:\")) {\n    iss = `did:pkh:${iss}`;\n  }\n\n  const authObject: AuthTypes.Cacao = {\n    h: {\n      t: \"caip122\",\n    },\n    p: {\n      iss,\n      domain: requestPayload.domain,\n      aud: requestPayload.aud,\n      version: requestPayload.version,\n      nonce: requestPayload.nonce,\n      iat: requestPayload.iat,\n      statement: requestPayload.statement,\n      requestId: requestPayload.requestId,\n      resources: requestPayload.resources,\n      nbf: requestPayload.nbf,\n      exp: requestPayload.exp,\n    },\n    s: signature,\n  };\n  return authObject;\n}\ntype PopulateAuthPayloadParams = {\n  authPayload: AuthTypes.PayloadParams;\n  chains: string[];\n  methods: string[];\n};\nexport function populateAuthPayload(params: PopulateAuthPayloadParams): AuthTypes.PayloadParams {\n  const { authPayload, chains, methods } = params;\n  const statement = authPayload.statement || \"\";\n\n  if (!chains?.length) return authPayload;\n\n  const requested = authPayload.chains;\n  const supported = chains;\n\n  const supportedChains = getCommonValuesInArrays<string>(requested, supported);\n  if (!supportedChains?.length) {\n    throw new Error(\"No supported chains\");\n  }\n\n  const requestedRecaps = getDecodedRecapFromResources(authPayload.resources);\n  if (!requestedRecaps) return authPayload;\n\n  isValidRecap(requestedRecaps);\n  const resource = getRecapResource(requestedRecaps, \"eip155\");\n  let updatedResources = authPayload?.resources || [];\n\n  if (resource?.length) {\n    const actions = getReCapActions(resource);\n    const supportedActions = getCommonValuesInArrays<string>(actions, methods);\n    if (!supportedActions?.length) {\n      throw new Error(\n        `Supported methods don't satisfy the requested: ${JSON.stringify(\n          actions,\n        )}, supported: ${JSON.stringify(methods)}`,\n      );\n    }\n    const formattedActions = assignAbilityToActions(\"request\", supportedActions as string[], {\n      chains: supportedChains,\n    });\n    const updatedRecap = addResourceToRecap(requestedRecaps, \"eip155\", formattedActions);\n    // remove recap from resources as we will add the updated one\n    updatedResources = authPayload?.resources?.slice(0, -1) || [];\n    updatedResources.push(encodeRecap(updatedRecap));\n  }\n\n  return {\n    ...authPayload,\n    statement: buildRecapStatement(statement, getRecapFromResources(updatedResources)),\n    chains: supportedChains,\n    resources: authPayload?.resources || updatedResources.length > 0 ? updatedResources : undefined,\n  };\n}\n\nexport function getDecodedRecapFromResources(resources?: string[]) {\n  const resource = getRecapFromResources(resources);\n  if (!resource) return;\n  if (!isRecap(resource)) return;\n  return decodeRecap(resource);\n}\n\nexport function recapHasResource(recap: any, resource: string) {\n  return recap?.att?.hasOwnProperty(resource);\n}\n\nexport function getRecapResource(recap: any, resource: string): any[] {\n  return recap?.att?.[resource] ? Object.keys(recap?.att?.[resource]) : [];\n}\n\nexport function getRecapAbilitiesFromResource(actions: any[]) {\n  return actions?.map((action) => Object.keys(action)) || [];\n}\n\nexport function getReCapActions(abilities: any[]) {\n  return abilities?.map((ability) => ability.split(\"/\")?.[1]) || [];\n}\n\nexport function base64Encode(input: unknown): string {\n  return Buffer.from(JSON.stringify(input)).toString(\"base64\");\n}\n\nexport function base64Decode(encodedString: string): string {\n  return JSON.parse(Buffer.from(encodedString, \"base64\").toString(\"utf-8\"));\n}\n\nexport function isValidRecap(recap: any) {\n  if (!recap) throw new Error(\"No recap provided, value is undefined\");\n  if (!recap.att) throw new Error(\"No `att` property found\");\n  const resources = Object.keys(recap.att);\n  if (!resources?.length) throw new Error(\"No resources found in `att` property\");\n  resources.forEach((resource) => {\n    const resourceAbilities = recap.att[resource];\n    if (Array.isArray(resourceAbilities))\n      throw new Error(`Resource must be an object: ${resource}`);\n    if (typeof resourceAbilities !== \"object\")\n      throw new Error(`Resource must be an object: ${resource}`);\n    if (!Object.keys(resourceAbilities).length)\n      throw new Error(`Resource object is empty: ${resource}`);\n\n    Object.keys(resourceAbilities).forEach((ability) => {\n      const limits = resourceAbilities[ability];\n      if (!Array.isArray(limits))\n        throw new Error(`Ability limits ${ability} must be an array of objects, found: ${limits}`);\n      if (!limits.length)\n        throw new Error(`Value of ${ability} is empty array, must be an array with objects`);\n      limits.forEach((limit) => {\n        if (typeof limit !== \"object\")\n          throw new Error(\n            `Ability limits (${ability}) must be an array of objects, found: ${limit}`,\n          );\n      });\n    });\n  });\n}\n\nexport function createRecap(resource: string, ability: string, actions: string[], limits = {}) {\n  actions?.sort((a, b) => a.localeCompare(b));\n  return {\n    att: { [resource]: assignAbilityToActions(ability, actions, limits) },\n  };\n}\n\ntype RecapType = {\n  att: {\n    [key: string]: Record<string, unknown>;\n  };\n};\nexport function addResourceToRecap(recap: RecapType, resource: string, actions: unknown[]) {\n  recap.att[resource] = {\n    ...actions,\n  };\n  const keys = Object.keys(recap.att)?.sort((a, b) => a.localeCompare(b));\n  const sorted = keys.reduce(\n    (obj, key) => {\n      obj.att[key] = recap.att[key];\n      return obj;\n    },\n    { att: {} },\n  );\n  return sorted;\n}\n\nexport function assignAbilityToActions(ability: string, actions: string[], limits = {}) {\n  // sort resources alphabetically\n  actions = actions?.sort((a, b) => a.localeCompare(b));\n  const abilities = actions.map((action) => {\n    return {\n      [`${ability}/${action}`]: [limits],\n    };\n  });\n  return Object.assign({}, ...abilities);\n}\n\nexport function encodeRecap(recap: any) {\n  isValidRecap(recap);\n  // remove the padding from the base64 string as per recap spec\n  return `urn:recap:${base64Encode(recap).replace(/=/g, \"\")}`;\n}\n\nexport function decodeRecap(recap: any): RecapType {\n  // base64Decode adds padding internally so don't need to add it back if it was removed\n  const decoded = base64Decode(recap.replace(\"urn:recap:\", \"\"));\n  isValidRecap(decoded);\n  return decoded as unknown as RecapType;\n}\n\nexport function createEncodedRecap(resource: string, ability: string, actions: string[]): string {\n  const recap = createRecap(resource, ability, actions);\n  return encodeRecap(recap);\n}\n\nexport function isRecap(resource: string) {\n  return resource && resource.includes(\"urn:recap:\");\n}\n\nexport function mergeEncodedRecaps(recap1: string, recap2: string) {\n  const decoded1 = decodeRecap(recap1);\n  const decoded2 = decodeRecap(recap2);\n  const merged = mergeRecaps(decoded1, decoded2);\n  return encodeRecap(merged);\n}\n\nexport function mergeRecaps(recap1: RecapType, recap2: RecapType) {\n  isValidRecap(recap1);\n  isValidRecap(recap2);\n  const keys = Object.keys(recap1.att)\n    .concat(Object.keys(recap2.att))\n    .sort((a, b) => a.localeCompare(b));\n  const mergedRecap = { att: {} };\n  keys.forEach((key) => {\n    const actions = Object.keys(recap1.att?.[key] || {})\n      .concat(Object.keys(recap2.att?.[key] || {}))\n      .sort((a, b) => a.localeCompare(b));\n    actions.forEach((action) => {\n      mergedRecap.att[key] = {\n        ...mergedRecap.att[key],\n        [action]: recap1.att[key]?.[action] || recap2.att[key]?.[action],\n      };\n    });\n  });\n  return mergedRecap;\n}\n\nexport function formatStatementFromRecap(statement = \"\", recap: RecapType) {\n  isValidRecap(recap);\n  const base = \"I further authorize the stated URI to perform the following actions on my behalf: \";\n\n  if (statement.includes(base)) return statement;\n\n  const statementForRecap: string[] = [];\n  let currentCounter = 0;\n  Object.keys(recap.att).forEach((resource) => {\n    const actions = Object.keys(recap.att[resource]).map((ability: any) => {\n      return {\n        ability: ability.split(\"/\")[0],\n        action: ability.split(\"/\")[1],\n      };\n    });\n    //\n    actions.sort((a, b) => a.action.localeCompare(b.action));\n    const uniqueAbilities = {};\n    actions.forEach((action: any) => {\n      if (!uniqueAbilities[action.ability]) {\n        uniqueAbilities[action.ability] = [];\n      }\n      uniqueAbilities[action.ability].push(action.action);\n    });\n    const abilities = Object.keys(uniqueAbilities).map((ability) => {\n      currentCounter++;\n      return `(${currentCounter}) '${ability}': '${uniqueAbilities[ability].join(\n        \"', '\",\n      )}' for '${resource}'.`;\n    });\n    statementForRecap.push(abilities.join(\", \").replace(\".,\", \".\"));\n  });\n\n  const recapStatemet = statementForRecap.join(\" \");\n  const recapStatement = `${base}${recapStatemet}`;\n  // add a space if there is a statement\n  return `${statement ? statement + \" \" : \"\"}${recapStatement}`;\n}\n\nexport function getMethodsFromRecap(recap: string) {\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  // methods are only available for eip155 as per the current implementation\n  const resource = decoded.att?.eip155;\n  if (!resource) return [];\n  return Object.keys(resource).map((ability: any) => ability.split(\"/\")[1]);\n}\n\nexport function getChainsFromRecap(recap: string) {\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  const chains: string[] = [];\n\n  Object.values(decoded.att).forEach((resource: any) => {\n    Object.values(resource).forEach((ability: any) => {\n      if (ability?.[0]?.chains) {\n        chains.push(ability[0].chains);\n      }\n    });\n  });\n  return [...new Set(chains.flat())];\n}\n\nexport function buildRecapStatement(statement: string, recap: unknown) {\n  if (!recap) return statement;\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  return formatStatementFromRecap(statement, decoded);\n}\n\nexport function getRecapFromResources(resources?: string[]) {\n  if (!resources) return;\n  // per spec, recap is always the last resource\n  const resource = resources?.[resources.length - 1];\n  return isRecap(resource) ? resource : undefined;\n}\n","import { ChaCha20Poly1305 } from \"@stablelib/chacha20poly1305\";\nimport { HKDF } from \"@stablelib/hkdf\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { hash, SHA256 } from \"@stablelib/sha256\";\nimport * as x25519 from \"@stablelib/x25519\";\nimport { CryptoTypes } from \"@walletconnect/types\";\nimport { concat, fromString, toString } from \"uint8arrays\";\nimport { ec as EC } from \"elliptic\";\nimport { decodeJWT } from \"@walletconnect/relay-auth\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const BASE64URL = \"base64url\";\nexport const UTF8 = \"utf8\";\n\nexport const TYPE_0 = 0;\nexport const TYPE_1 = 1;\nexport const TYPE_2 = 2;\n\nexport type P256KeyDataType = {\n  crv: \"P-256\";\n  ext: true;\n  key_ops: [\"verify\"];\n  kty: string;\n  x: string;\n  y: string;\n};\n\nconst ZERO_INDEX = 0;\nconst TYPE_LENGTH = 1;\nconst IV_LENGTH = 12;\nconst KEY_LENGTH = 32;\n\nexport function generateKeyPair(): CryptoTypes.KeyPair {\n  const keyPair = x25519.generateKeyPair();\n  return {\n    privateKey: toString(keyPair.secretKey, BASE16),\n    publicKey: toString(keyPair.publicKey, BASE16),\n  };\n}\n\nexport function generateRandomBytes32(): string {\n  const random = randomBytes(KEY_LENGTH);\n  return toString(random, BASE16);\n}\n\nexport function deriveSymKey(privateKeyA: string, publicKeyB: string): string {\n  const sharedKey = x25519.sharedKey(\n    fromString(privateKeyA, BASE16),\n    fromString(publicKeyB, BASE16),\n    true,\n  );\n  const hkdf = new HKDF(SHA256, sharedKey);\n  const symKey = hkdf.expand(KEY_LENGTH);\n  return toString(symKey, BASE16);\n}\n\nexport function hashKey(key: string): string {\n  const result = hash(fromString(key, BASE16));\n  return toString(result, BASE16);\n}\n\nexport function hashMessage(message: string): string {\n  const result = hash(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n\nexport function encodeTypeByte(type: number): Uint8Array {\n  return fromString(`${type}`, BASE10);\n}\n\nexport function decodeTypeByte(byte: Uint8Array): number {\n  return Number(toString(byte, BASE10));\n}\n\nexport function encrypt(params: CryptoTypes.EncryptParams): string {\n  const type = encodeTypeByte(typeof params.type !== \"undefined\" ? params.type : TYPE_0);\n  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === \"undefined\") {\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  }\n  const senderPublicKey =\n    typeof params.senderPublicKey !== \"undefined\"\n      ? fromString(params.senderPublicKey, BASE16)\n      : undefined;\n\n  const iv =\n    typeof params.iv !== \"undefined\" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const sealed = box.seal(iv, fromString(params.message, UTF8));\n  return serialize({ type, sealed, iv, senderPublicKey, encoding: params.encoding });\n}\n\nexport function encodeTypeTwoEnvelope(\n  message: string,\n  encoding?: CryptoTypes.EncodingType,\n): string {\n  const type = encodeTypeByte(TYPE_2);\n  // iv is not used in type 2 envelopes\n  const iv = randomBytes(IV_LENGTH);\n  const sealed = fromString(message, UTF8);\n  return serialize({ type, sealed, iv, encoding });\n}\n\nexport function decrypt(params: CryptoTypes.DecryptParams): string {\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const { sealed, iv } = deserialize({ encoded: params.encoded, encoding: params?.encoding });\n  const message = box.open(iv, sealed);\n  if (message === null) throw new Error(\"Failed to decrypt\");\n  return toString(message, UTF8);\n}\n\nexport function decodeTypeTwoEnvelope(\n  encoded: string,\n  encoding?: CryptoTypes.EncodingType,\n): string {\n  const { sealed } = deserialize({ encoded, encoding });\n  return toString(sealed, UTF8);\n}\n\nexport function serialize(params: CryptoTypes.EncodingParams): string {\n  const { encoding = BASE64 } = params;\n\n  if (decodeTypeByte(params.type) === TYPE_2) {\n    return toString(concat([params.type, params.sealed]), encoding);\n  }\n  if (decodeTypeByte(params.type) === TYPE_1) {\n    if (typeof params.senderPublicKey === \"undefined\") {\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    }\n    return toString(\n      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),\n      encoding,\n    );\n  }\n  // default to type 0 envelope\n  return toString(concat([params.type, params.iv, params.sealed]), encoding);\n}\n\nexport function deserialize(params: CryptoTypes.DecodingParams): CryptoTypes.EncodingParams {\n  const { encoded, encoding = BASE64 } = params;\n  const bytes = fromString(encoded, encoding);\n  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);\n  const slice1 = TYPE_LENGTH;\n  if (decodeTypeByte(type) === TYPE_1) {\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + IV_LENGTH;\n    const senderPublicKey = bytes.slice(slice1, slice2);\n    const iv = bytes.slice(slice2, slice3);\n    const sealed = bytes.slice(slice3);\n    return { type, sealed, iv, senderPublicKey };\n  }\n  if (decodeTypeByte(type) === TYPE_2) {\n    const sealed = bytes.slice(slice1);\n    // iv is not used in type 2 envelopes\n    const iv = randomBytes(IV_LENGTH);\n    return { type, sealed, iv };\n  }\n  // default to type 0 envelope\n  const slice2 = slice1 + IV_LENGTH;\n  const iv = bytes.slice(slice1, slice2);\n  const sealed = bytes.slice(slice2);\n  return { type, sealed, iv };\n}\n\nexport function validateDecoding(\n  encoded: string,\n  opts?: CryptoTypes.DecodeOptions,\n): CryptoTypes.EncodingValidation {\n  const deserialized = deserialize({ encoded, encoding: opts?.encoding });\n  return validateEncoding({\n    type: decodeTypeByte(deserialized.type),\n    senderPublicKey:\n      typeof deserialized.senderPublicKey !== \"undefined\"\n        ? toString(deserialized.senderPublicKey, BASE16)\n        : undefined,\n    receiverPublicKey: opts?.receiverPublicKey,\n  });\n}\n\nexport function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {\n  const type = opts?.type || TYPE_0;\n  if (type === TYPE_1) {\n    if (typeof opts?.senderPublicKey === \"undefined\") {\n      throw new Error(\"missing sender public key\");\n    }\n    if (typeof opts?.receiverPublicKey === \"undefined\") {\n      throw new Error(\"missing receiver public key\");\n    }\n  }\n  return {\n    type,\n    senderPublicKey: opts?.senderPublicKey,\n    receiverPublicKey: opts?.receiverPublicKey,\n  };\n}\n\nexport function isTypeOneEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return (\n    result.type === TYPE_1 &&\n    typeof result.senderPublicKey === \"string\" &&\n    typeof result.receiverPublicKey === \"string\"\n  );\n}\n\nexport function isTypeTwoEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return result.type === TYPE_2;\n}\nexport function getCryptoKeyFromKeyData(keyData: P256KeyDataType): EC.KeyPair {\n  const ec = new EC(\"p256\");\n  const key = ec.keyFromPublic(\n    {\n      x: Buffer.from(keyData.x, \"base64\").toString(\"hex\"),\n      y: Buffer.from(keyData.y, \"base64\").toString(\"hex\"),\n    },\n    \"hex\",\n  );\n  return key;\n}\n\nfunction base64UrlToBase64(base64Url: string) {\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padding = base64.length % 4;\n  if (padding > 0) {\n    base64 += \"=\".repeat(4 - padding);\n  }\n  return base64;\n}\n\nfunction base64UrlDecode(base64Url: string) {\n  return Buffer.from(base64UrlToBase64(base64Url), \"base64\");\n}\n\nexport function verifyP256Jwt<T>(token: string, keyData: P256KeyDataType) {\n  const [headerBase64Url, payloadBase64Url, signatureBase64Url] = token.split(\".\");\n\n  // Decode the signature\n  const signatureBuffer = base64UrlDecode(signatureBase64Url);\n\n  // Check if signature length is correct (64 bytes for P-256)\n  if (signatureBuffer.length !== 64) {\n    throw new Error(\"Invalid signature length\");\n  }\n\n  // Extract r and s from the signature\n  const r = signatureBuffer.slice(0, 32).toString(\"hex\");\n  const s = signatureBuffer.slice(32, 64).toString(\"hex\");\n\n  // Create the signing input\n  const signingInput = `${headerBase64Url}.${payloadBase64Url}`;\n\n  const sha256 = new SHA256();\n  const buffer = sha256.update(Buffer.from(signingInput)).digest();\n\n  const key = getCryptoKeyFromKeyData(keyData);\n\n  // Convert the hash to hex format\n  const hashHex = Buffer.from(buffer).toString(\"hex\");\n\n  // Verify the signature\n  const isValid = key.verify(hashHex, { r, s });\n\n  if (!isValid) {\n    throw new Error(\"Invalid signature\");\n  }\n  const data = decodeJWT(token) as unknown as { payload: T };\n  return data.payload;\n}\n","import { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { RelayerTypes } from \"@walletconnect/types\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport function getRelayProtocolName(\n  opts?: RelayerTypes.RequestOptions,\n): RelayerTypes.ProtocolOptions {\n  return opts?.relay || { protocol: RELAYER_DEFAULT_PROTOCOL };\n}\n\nexport function getRelayProtocolApi(protocol: string) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n  return jsonrpc;\n}\n","import * as qs from \"query-string\";\nimport { EngineTypes, RelayerTypes } from \"@walletconnect/types\";\nimport { fromBase64 } from \"./misc\";\n\n// -- uri -------------------------------------------------- //\n\nexport function parseRelayParams(params: any, delimiter = \"-\"): RelayerTypes.ProtocolOptions {\n  const relay: any = {};\n  const prefix = \"relay\" + delimiter;\n  Object.keys(params).forEach((key) => {\n    if (key.startsWith(prefix)) {\n      const name = key.replace(prefix, \"\");\n      const value = params[key];\n      relay[name] = value;\n    }\n  });\n  return relay;\n}\n\nexport function parseUri(str: string): EngineTypes.UriParameters {\n  if (!str.includes(\"wc:\")) {\n    const parsed = fromBase64(str);\n    if (parsed?.includes(\"wc:\")) {\n      str = parsed;\n    }\n  }\n\n  // remove android schema prefix\n  str = str.includes(\"wc://\") ? str.replace(\"wc://\", \"\") : str;\n  // remove ios schema prefix\n  str = str.includes(\"wc:\") ? str.replace(\"wc:\", \"\") : str;\n  const pathStart: number = str.indexOf(\":\");\n  const pathEnd: number | undefined = str.indexOf(\"?\") !== -1 ? str.indexOf(\"?\") : undefined;\n  const protocol: string = str.substring(0, pathStart);\n  const path: string = str.substring(pathStart + 1, pathEnd);\n  const requiredValues = path.split(\"@\");\n  const queryString: string = typeof pathEnd !== \"undefined\" ? str.substring(pathEnd) : \"\";\n  const queryParams = qs.parse(queryString);\n  const methods =\n    typeof queryParams.methods === \"string\" ? queryParams.methods.split(\",\") : undefined;\n  const result = {\n    protocol,\n    topic: parseTopic(requiredValues[0]),\n    version: parseInt(requiredValues[1], 10),\n    symKey: queryParams.symKey as string,\n    relay: parseRelayParams(queryParams),\n    methods,\n    expiryTimestamp: queryParams.expiryTimestamp\n      ? parseInt(queryParams.expiryTimestamp as string, 10)\n      : undefined,\n  };\n  return result;\n}\n\nexport function parseTopic(topic: string): string {\n  return topic.startsWith(\"//\") ? topic.substring(2) : topic;\n}\n\nexport function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = \"-\") {\n  const prefix = \"relay\";\n  const params: any = {};\n  Object.keys(relay).forEach((key) => {\n    const k = prefix + delimiter + key;\n    if (relay[key]) {\n      params[k] = relay[key];\n    }\n  });\n  return params;\n}\n\nexport function formatUri(params: EngineTypes.UriParameters): string {\n  return (\n    `${params.protocol}:${params.topic}@${params.version}?` +\n    qs.stringify({\n      symKey: params.symKey,\n      ...formatRelayParams(params.relay),\n      expiryTimestamp: params.expiryTimestamp,\n      ...(params.methods ? { methods: params.methods.join(\",\") } : {}),\n    })\n  );\n}\n\nexport function getLinkModeURL(\n  universalLink: string,\n  topic: string,\n  encodedEnvelope: string,\n): string {\n  return `${universalLink}?wc_ev=${encodedEnvelope}&topic=${topic}`;\n}\n","import { ProposalTypes, SessionTypes } from \"@walletconnect/types\";\nimport { mergeArrays } from \"./misc\";\nimport { isConformingNamespaces, isValidNamespaces, isValidObject } from \"./validators\";\n\nexport function getAccountsChains(accounts: SessionTypes.Namespace[\"accounts\"]) {\n  const chains: string[] = [];\n  accounts.forEach((account) => {\n    const [chain, chainId] = account.split(\":\");\n    chains.push(`${chain}:${chainId}`);\n  });\n\n  return chains;\n}\n\nexport function getNamespacesChains(namespaces: SessionTypes.Namespaces) {\n  const chains: string[] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    chains.push(...getAccountsChains(namespace.accounts));\n  });\n\n  return chains;\n}\n\nexport function getNamespacesMethodsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const methods: SessionTypes.Namespace[\"methods\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) methods.push(...namespace.methods);\n  });\n\n  return methods;\n}\n\nexport function getNamespacesEventsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const events: SessionTypes.Namespace[\"events\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) events.push(...namespace.events);\n  });\n\n  return events;\n}\n\nexport function getRequiredNamespacesFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  caller: string,\n): ProposalTypes.RequiredNamespaces {\n  const validNamespacesError = isValidNamespaces(namespaces, caller);\n  if (validNamespacesError) throw new Error(validNamespacesError.message);\n\n  const required = {};\n  for (const [namespace, values] of Object.entries(namespaces)) {\n    required[namespace] = {\n      methods: values.methods,\n      events: values.events,\n      chains: values.accounts.map((account) => `${account.split(\":\")[0]}:${account.split(\":\")[1]}`),\n    };\n  }\n  return required;\n}\n\nexport type BuildApprovedNamespacesParams = {\n  proposal: ProposalTypes.Struct;\n  supportedNamespaces: Record<\n    string,\n    { chains: string[]; methods: string[]; events: string[]; accounts: string[] }\n  >;\n};\n\n/**\n * util designed for Wallets that builds namespaces structure by provided supported chains, methods, events & accounts.\n * It takes required & optional namespaces provided in the session proposal\n * along with the supported chains/methods/events/accounts by the wallet and returns a structured namespaces object\n * @param {BuildApprovedNamespacesParams} params\n * @returns {SessionTypes.Namespaces}\n */\nexport function buildApprovedNamespaces(\n  params: BuildApprovedNamespacesParams,\n): SessionTypes.Namespaces {\n  const {\n    proposal: { requiredNamespaces, optionalNamespaces = {} },\n    supportedNamespaces,\n  } = params;\n  const normalizedRequired = normalizeNamespaces(requiredNamespaces);\n  const normalizedOptional = normalizeNamespaces(optionalNamespaces);\n\n  // build approved namespaces\n  const namespaces = {};\n  Object.keys(supportedNamespaces).forEach((namespace) => {\n    const supportedChains = supportedNamespaces[namespace].chains;\n    const supportedMethods = supportedNamespaces[namespace].methods;\n    const supportedEvents = supportedNamespaces[namespace].events;\n    const supportedAccounts = supportedNamespaces[namespace].accounts;\n\n    supportedChains.forEach((chain) => {\n      if (!supportedAccounts.some((account) => account.includes(chain))) {\n        throw new Error(`No accounts provided for chain ${chain} in namespace ${namespace}`);\n      }\n    });\n\n    namespaces[namespace] = {\n      chains: supportedChains,\n      methods: supportedMethods,\n      events: supportedEvents,\n      accounts: supportedAccounts,\n    };\n  });\n\n  // verify all required namespaces are supported\n  const err = isConformingNamespaces(requiredNamespaces, namespaces, \"approve()\");\n  if (err) throw new Error(err.message);\n\n  const approvedNamespaces = {};\n\n  // if both required & optional namespaces are empty, return all supported namespaces by the wallet\n  if (!Object.keys(requiredNamespaces).length && !Object.keys(optionalNamespaces).length)\n    return namespaces;\n\n  // assign accounts for the required namespaces\n  Object.keys(normalizedRequired).forEach((requiredNamespace) => {\n    const chains = supportedNamespaces[requiredNamespace].chains.filter((chain) =>\n      normalizedRequired[requiredNamespace]?.chains?.includes(chain),\n    );\n    const methods = supportedNamespaces[requiredNamespace].methods.filter((method) =>\n      normalizedRequired[requiredNamespace]?.methods?.includes(method),\n    );\n    const events = supportedNamespaces[requiredNamespace].events.filter((event) =>\n      normalizedRequired[requiredNamespace]?.events?.includes(event),\n    );\n\n    const accounts = chains\n      .map((chain: string) =>\n        supportedNamespaces[requiredNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[requiredNamespace] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  });\n\n  // add optional namespaces\n  Object.keys(normalizedOptional).forEach((optionalNamespace) => {\n    if (!supportedNamespaces[optionalNamespace]) return;\n\n    const chainsToAdd = normalizedOptional[optionalNamespace]?.chains?.filter((chain) =>\n      supportedNamespaces[optionalNamespace].chains.includes(chain),\n    );\n    const methodsToAdd = supportedNamespaces[optionalNamespace].methods.filter((method) =>\n      normalizedOptional[optionalNamespace]?.methods?.includes(method),\n    );\n    const eventsToAdd = supportedNamespaces[optionalNamespace].events.filter((event) =>\n      normalizedOptional[optionalNamespace]?.events?.includes(event),\n    );\n\n    const accountsToAdd = chainsToAdd\n      ?.map((chain: string) =>\n        supportedNamespaces[optionalNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[optionalNamespace] = {\n      chains: mergeArrays(approvedNamespaces[optionalNamespace]?.chains, chainsToAdd),\n      methods: mergeArrays(approvedNamespaces[optionalNamespace]?.methods, methodsToAdd),\n      events: mergeArrays(approvedNamespaces[optionalNamespace]?.events, eventsToAdd),\n      accounts: mergeArrays(approvedNamespaces[optionalNamespace]?.accounts, accountsToAdd),\n    };\n  });\n\n  return approvedNamespaces;\n}\n\nexport function isCaipNamespace(namespace: string): boolean {\n  return namespace.includes(\":\");\n}\n\nexport function parseNamespaceKey(namespace: string) {\n  return isCaipNamespace(namespace) ? namespace.split(\":\")[0] : namespace;\n}\n\n/**\n * Converts\n * ```\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * ```\n * into\n * ```\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *```\n */\nexport function normalizeNamespaces(\n  namespaces: ProposalTypes.RequiredNamespaces,\n): ProposalTypes.RequiredNamespaces {\n  const normalizedNamespaces = {} as ProposalTypes.RequiredNamespaces;\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n  }\n  return normalizedNamespaces;\n}\n\nexport function getNamespacesFromAccounts(accounts: string[]) {\n  const namespaces = {};\n  accounts?.forEach((account) => {\n    const [namespace, chainId] = account.split(\":\");\n    if (!namespaces[namespace]) {\n      namespaces[namespace] = {\n        accounts: [],\n        chains: [],\n        events: [],\n      };\n    }\n    namespaces[namespace].accounts.push(account);\n    namespaces[namespace].chains.push(`${namespace}:${chainId}`);\n  });\n\n  return namespaces;\n}\n\nexport function buildNamespacesFromAuth(methods: string[], accounts: string[]) {\n  accounts = accounts.map((account) => account.replace(\"did:pkh:\", \"\"));\n\n  const namespaces = getNamespacesFromAccounts(accounts);\n\n  for (const [_, values] of Object.entries(namespaces) as [string, SessionTypes.Namespace][]) {\n    if (!values.methods) {\n      values.methods = methods;\n    } else {\n      values.methods = mergeArrays(values.methods, methods);\n    }\n    values.events = [\"chainChanged\", \"accountsChanged\"];\n  }\n  return namespaces;\n}\n","/**\n * Types\n */\nexport type SdkErrorKey = keyof typeof SDK_ERRORS;\nexport type InternalErrorKey = keyof typeof INTERNAL_ERRORS;\n\n/**\n * Constants\n */\nexport const SDK_ERRORS = {\n  /* ----- INVALID (1xxx) ----- */\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001,\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002,\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003,\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004,\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005,\n  },\n  /* ----- UNAUTHORIZED (3xxx) ----- */\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001,\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002,\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003,\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004,\n  },\n  /* ----- REJECTED (5xxx) ----- */\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5000,\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001,\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002,\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003,\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100,\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101,\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102,\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103,\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104,\n  },\n  /* ----- REASON (6xxx) ----- */\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6000,\n  },\n  /* ----- FAILURE (7xxx) ----- */\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7000,\n  },\n  /* ----- PAIRING (10xxx) ----- */\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001,\n  },\n};\n\nexport const INTERNAL_ERRORS = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1,\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2,\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3,\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4,\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5,\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6,\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7,\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8,\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9,\n  },\n};\n\n/**\n * Utilities\n */\nexport function getInternalError(key: InternalErrorKey, context?: string | number) {\n  const { message, code } = INTERNAL_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n\nexport function getSdkError(key: SdkErrorKey, context?: string | number) {\n  const { message, code } = SDK_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n","import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from \"@walletconnect/types\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport {\n  getNamespacesChains,\n  getNamespacesMethodsForChainId,\n  getNamespacesEventsForChainId,\n  getAccountsChains,\n} from \"./namespaces\";\nimport { getSdkError, getInternalError } from \"./errors\";\nimport { fromBase64, hasOverlap } from \"./misc\";\nimport { getChainsFromNamespace } from \"./caip\";\n\nexport type ErrorObject = { message: string; code: number } | null;\n\n// -- types validation ----------------------------------------------------- //\n\nexport function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {\n  if (Array.isArray(arr)) {\n    if (typeof itemCondition !== \"undefined\" && arr.length) {\n      return arr.every(itemCondition);\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isValidObject(obj: any) {\n  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;\n}\n\nexport function isUndefined(input: any): input is undefined {\n  return typeof input === \"undefined\";\n}\n\nexport function isValidString(input: any, optional: boolean): input is string {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"string\" && Boolean(input.trim().length);\n}\n\nexport function isValidNumber(input: any, optional: boolean) {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"number\" && !isNaN(input);\n}\n\n// -- protocol validation -------------------------------------------------- //\n\nexport function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {\n  const { requiredNamespaces } = params;\n  const sessionKeys = Object.keys(session.namespaces);\n  const paramsKeys = Object.keys(requiredNamespaces);\n  let compatible = true;\n\n  if (!hasOverlap(paramsKeys, sessionKeys)) return false;\n\n  sessionKeys.forEach((key) => {\n    const { accounts, methods, events } = session.namespaces[key];\n    const chains = getAccountsChains(accounts);\n    const requiredNamespace = requiredNamespaces[key];\n    if (\n      !hasOverlap(getChainsFromNamespace(key, requiredNamespace), chains) ||\n      !hasOverlap(requiredNamespace.methods, methods) ||\n      !hasOverlap(requiredNamespace.events, events)\n    ) {\n      compatible = false;\n    }\n  });\n\n  return compatible;\n}\n\nexport function isValidChainId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    return split.length === 2;\n  }\n  return false;\n}\n\nexport function isValidAccountId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    if (split.length === 3) {\n      const chainId = split[0] + \":\" + split[1];\n      return !!split[2] && isValidChainId(chainId);\n    }\n  }\n  return false;\n}\n\nexport function isValidUrl(value: any) {\n  function validateUrl(blob: string) {\n    try {\n      const url = new URL(blob);\n      return typeof url !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n  try {\n    if (isValidString(value, false)) {\n      const isValid = validateUrl(value);\n      if (isValid) return true;\n\n      const decoded = fromBase64(value);\n      return validateUrl(decoded);\n    }\n  } catch (e) {}\n  return false;\n}\n\nexport function isProposalStruct(input: any): input is ProposalTypes.Struct {\n  return input?.proposer?.publicKey;\n}\n\nexport function isSessionStruct(input: any): input is SessionTypes.Struct {\n  return input?.topic;\n}\n\nexport function isValidController(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isValidString(input?.publicKey, false)) {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method} controller public key should be a string`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceMethodsOrEvents(input: any): input is string {\n  let valid = true;\n  if (isValidArray(input)) {\n    if (input.length) {\n      valid = input.every((item: any) => isValidString(item, false));\n    }\n  } else {\n    valid = false;\n  }\n\n  return valid;\n}\n\nexport function isValidChains(key: string, chains: any, context: string) {\n  let error: ErrorObject = null;\n\n  if (isValidArray(chains) && chains.length) {\n    chains.forEach((chain: any) => {\n      if (error) return;\n      if (!isValidChainId(chain)) {\n        error = getSdkError(\n          \"UNSUPPORTED_CHAINS\",\n          `${context}, chain ${chain} should be a string and conform to \"namespace:chainId\" format`,\n        );\n      }\n    });\n  } else if (!isValidChainId(key)) {\n    error = getSdkError(\n      \"UNSUPPORTED_CHAINS\",\n      `${context}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceChains(namespaces: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {\n    if (error) return;\n    const validChainsError = isValidChains(\n      key,\n      getChainsFromNamespace(key, namespace),\n      `${method} ${type}`,\n    );\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidAccounts(accounts: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(accounts)) {\n    accounts.forEach((account: any) => {\n      if (error) return;\n      if (!isValidAccountId(account)) {\n        error = getSdkError(\n          \"UNSUPPORTED_ACCOUNTS\",\n          `${context}, account ${account} should be a string and conform to \"namespace:chainId:address\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_ACCOUNTS\",\n      `${context}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceAccounts(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidActions(namespace: any, context: string) {\n  let error: ErrorObject = null;\n  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {\n    error = getSdkError(\n      \"UNSUPPORTED_METHODS\",\n      `${context}, methods should be an array of strings or empty array for no methods`,\n    );\n  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {\n    error = getSdkError(\n      \"UNSUPPORTED_EVENTS\",\n      `${context}, events should be an array of strings or empty array for no events`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceActions(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validActionsError = isValidActions(namespace, `${method}, namespace`);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidRequiredNamespaces(input: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validChainsError = isValidNamespaceChains(input, method, type);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, ${type} should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validAccountsError = isValidNamespaceAccounts(input, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, namespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {\n  return isValidString(input.protocol, true);\n}\n\nexport function isValidRelays(\n  input: any,\n  optional: boolean,\n): input is RelayerTypes.ProtocolOptions[] {\n  let valid = false;\n\n  if (optional && !input) valid = true;\n  else if (input && isValidArray(input) && input.length) {\n    input.forEach((relay: RelayerTypes.ProtocolOptions) => {\n      valid = isValidRelay(relay);\n    });\n  }\n\n  return valid;\n}\n\nexport function isValidId(input: any) {\n  return typeof input === \"number\";\n}\n\nexport function isValidParams(input: any) {\n  return typeof input !== \"undefined\" && typeof input !== null;\n}\n\nexport function isValidErrorReason(input: any): input is ErrorResponse {\n  if (!input) return false;\n  if (typeof input !== \"object\") return false;\n  if (!input.code || !isValidNumber(input.code, false)) return false;\n  if (!input.message || !isValidString(input.message, false)) return false;\n\n  return true;\n}\n\nexport function isValidRequest(request: any) {\n  if (isUndefined(request)) return false;\n  if (!isValidString(request.method, false)) return false;\n  return true;\n}\n\nexport function isValidResponse(response: any) {\n  if (isUndefined(response)) return false;\n  if (isUndefined(response.result) && isUndefined(response.error)) return false;\n  if (!isValidNumber(response.id, false)) return false;\n  if (!isValidString(response.jsonrpc, false)) return false;\n  return true;\n}\n\nexport function isValidEvent(event: any) {\n  if (isUndefined(event)) return false;\n  if (!isValidString(event.name, false)) return false;\n  return true;\n}\n\nexport function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {\n  if (!isValidChainId(chainId)) return false;\n  const chains = getNamespacesChains(namespaces);\n  if (!chains.includes(chainId)) return false;\n\n  return true;\n}\n\nexport function isValidNamespacesRequest(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  method: string,\n) {\n  if (!isValidString(method, false)) return false;\n  const methods = getNamespacesMethodsForChainId(namespaces, chainId);\n  return methods.includes(method);\n}\n\nexport function isValidNamespacesEvent(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  eventName: string,\n) {\n  if (!isValidString(eventName, false)) return false;\n  const events = getNamespacesEventsForChainId(namespaces, chainId);\n  return events.includes(eventName);\n}\n\nexport function isConformingNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  namespaces: SessionTypes.Namespaces,\n  context: string,\n) {\n  let error: ErrorObject = null;\n\n  const parsedRequired = parseNamespaces(requiredNamespaces);\n  const parsedApproved = parseApprovedNamespaces(namespaces);\n  const requiredChains = Object.keys(parsedRequired);\n  const approvedChains = Object.keys(parsedApproved);\n\n  const uniqueRequired = filterDuplicateNamespaces(Object.keys(requiredNamespaces));\n  const uniqueApproved = filterDuplicateNamespaces(Object.keys(namespaces));\n  const missingRequiredNamespaces = uniqueRequired.filter(\n    (namespace) => !uniqueApproved.includes(namespace),\n  );\n\n  if (missingRequiredNamespaces.length) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${missingRequiredNamespaces.toString()}\n      Received: ${Object.keys(namespaces).toString()}`,\n    );\n  }\n\n  if (!hasOverlap(requiredChains, approvedChains)) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces chains don't satisfy required namespaces.\n      Required: ${requiredChains.toString()}\n      Approved: ${approvedChains.toString()}`,\n    );\n  }\n\n  // validate inline defined chains with approved accounts\n  Object.keys(namespaces).forEach((chain) => {\n    if (!chain.includes(\":\")) return;\n    if (error) return;\n    const chains = getAccountsChains(namespaces[chain].accounts);\n    if (!chains.includes(chain)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces accounts don't satisfy namespace accounts for ${chain}\n        Required: ${chain}\n        Approved: ${chains.toString()}`,\n      );\n    }\n  });\n\n  requiredChains.forEach((chain) => {\n    if (error) return;\n\n    if (!hasOverlap(parsedRequired[chain].methods, parsedApproved[chain].methods)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces methods don't satisfy namespace methods for ${chain}`,\n      );\n    } else if (!hasOverlap(parsedRequired[chain].events, parsedApproved[chain].events)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces events don't satisfy namespace events for ${chain}`,\n      );\n    }\n  });\n\n  return error;\n}\n\nfunction parseNamespaces(namespaces: ProposalTypes.RequiredNamespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    // e.g. `eip155:1`\n    const isInlineChainDefinition = key.includes(\":\");\n\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      namespaces[key].chains?.forEach((chain) => {\n        parsed[chain] = {\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nfunction filterDuplicateNamespaces(namespaces: string[]) {\n  return [\n    ...new Set(\n      namespaces.map((namespace) =>\n        namespace.includes(\":\") ? namespace.split(\":\")[0] : namespace,\n      ),\n    ),\n  ];\n}\n\nfunction parseApprovedNamespaces(namespaces: SessionTypes.Namespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    const isInlineChainDefinition = key.includes(\":\");\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      const chains = getAccountsChains(namespaces[key].accounts);\n      chains?.forEach((chain) => {\n        parsed[chain] = {\n          accounts: namespaces[key].accounts.filter((account: string) =>\n            account.includes(`${chain}:`),\n          ),\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nexport function isValidRequestExpiry(expiry: number, boundaries: { min: number; max: number }) {\n  return isValidNumber(expiry, false) && expiry <= boundaries.max && expiry >= boundaries.min;\n}\n","import { getEnvironment, ENV_MAP, isBrowser, isReactNative } from \"./misc\";\n\nexport function isOnline(): Promise<boolean> {\n  const env = getEnvironment();\n  return new Promise((resolve) => {\n    switch (env) {\n      case ENV_MAP.browser:\n        resolve(getBrowserOnlineStatus());\n        break;\n      case ENV_MAP.reactNative:\n        resolve(getReactNativeOnlineStatus());\n        break;\n      case ENV_MAP.node:\n        resolve(getNodeOnlineStatus());\n        break;\n      default:\n        resolve(true);\n    }\n  });\n}\n\nexport function getBrowserOnlineStatus() {\n  return isBrowser() && navigator?.onLine;\n}\n\nexport async function getReactNativeOnlineStatus(): Promise<boolean> {\n  // global.NetInfo is set in react-native-compat\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    const state = await (global as any)?.NetInfo.fetch();\n    return state?.isConnected;\n  }\n  // fallback to true if global.NetInfo is undefined, meaning an older version of react-native-compat is used\n  return true;\n}\n\nexport function getNodeOnlineStatus() {\n  /**\n   * TODO: need to implement\n   */\n  return true;\n}\n\nexport function subscribeToNetworkChange(callbackHandler: (connected: boolean) => void) {\n  const env = getEnvironment();\n  switch (env) {\n    case ENV_MAP.browser:\n      subscribeToBrowserNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.reactNative:\n      subscribeToReactNativeNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.node:\n      // wip: need to implement\n      break;\n    default:\n      break;\n  }\n}\n\nexport function subscribeToBrowserNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (!isReactNative() && isBrowser()) {\n    window.addEventListener(\"online\", () => callbackHandler(true));\n    window.addEventListener(\"offline\", () => callbackHandler(false));\n  }\n}\n\n// global.NetInfo is set in react-native-compat\nexport function subscribeToReactNativeNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    (global as any)?.NetInfo.addEventListener((state: any) => callbackHandler(state?.isConnected));\n  }\n}\n","const memoryStore = {};\n\nexport abstract class MemoryStore {\n  static get<T = unknown>(key: string) {\n    return memoryStore[key] as T | undefined;\n  }\n\n  static set(key: string, value: unknown) {\n    memoryStore[key] = value;\n  }\n\n  static delete(key: string) {\n    delete memoryStore[key];\n  }\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}